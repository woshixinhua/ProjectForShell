
////////////////////////////////////////第一天////////////////////////
C 语言
一.学习方法

二.计算机组成与软件的关系
三.计算机语言的发展及编译
四.C语言结构的深层剖析

  源码   .c 标准C源码   .cpp或.c++ c++的源码
  头文件 .h 标准C头文件 .hpp或.h   c++的头文件 
  汇编   .s
  机器码 .o
  
  
  #include <stdio.h>
  int main(int argc,char **argv){
     return 0;
  }  

1.#include 引入头文件
  本质：是把头文件的代码插入到.c文件中
  源码：  函数体、全局变量
  头文件: 自定义的数据类型、宏定义、函数扩展声明
        常用的头文件
        stdio.h    标准输入输出
           函数体，有大括号，实现函数
           声明，没有大括号，用于通知编译器，函数已存在
        stdlib.h   标准库 内存的申请和处理函数
        string.h   字符串处理的函数
        math.h     数学运算函数
  <>    代表从 /usr/include内找头文件
  ""    代表从 当前目找头文件  
  
  #includ  #if  #ifndef #endif #define 不是C语言
  是编译指令，所有这些指令在编译时都被替换为c代码

2. 函数
  所有c语言代码写在函数内
  代码执行时，不是从文件的上面向下执行，而是在一个函数内从上向下执行  
  main 称为主函数，是程序的入口，必须唯一
  其它函数都是从主函数开始被调用的
  
  在一个数中，不可以嵌套定义函数，即不可以在一个函数内定函数
  
  格式:
  返回类型 函数名(形参列表){
     语句;
     return 返回值;
  }
  返回类型：代表了函数运算结果(返回值)的数据类型
  1) 数据类型：基本类型、自定义类型
     基本类型: int long short char double float
              不确定 4     2     1    8      4  字节
     自定义类型：指针类型、枚举、联合体、结构体、类
     
     指针类型：任意类型后面加"*" 就称为指针类型，用于保存内存的地址.
     void 空类型  如果返回类型是void 代表函数没有返回值（即函数不需要计算结果）。
     void* 任意类型指针，保存任意类型的内存地址
 2) return 
    本质，是结束函数。如果函数有返回类型，则必须用return 指定返回的值
    
    return 结束函数
    exit   结束程序
    break  结束循环或switch
 3) 参数
    形参：在函数定义时写的参数，本质是定义变量，也称为形参变量:
    实参：在函数调用时写的参数，本质是具体的值(常量、表达式、或具有值的变量),用途是给形参赋值。
    如果一个函数没有形参，也必须有()
 4) 语句
    表达式: 具有运算符的公式
    语句：具有分号的表达式
    ; 用来结束语句  
    单纯的分号，称为空语句
 5) 变量的定义
    格式:
       类型 变量名[=值];
       int a; //int 是类型 a是变量名
       
       定义变量的时候，就是分配内存的过程，a就是内存的名. &a 就是内存地址(内存地址就是电容排列了位置)  
                                  
    初始化：即分配内存的同时赋值的过程
       int a=12;

 6)函数的调用
    函数名(实参列表);
    
    int a=max(12,23); //max(12,23)是函数调用，函数调用的表达式本身就代表了return返回的值
    int a是又分配了一个内存a,将max(12,23)的值保存到a中
    printf("%d\n",max(12,23)); //max(12,23)是函数调用，用max(12,23)内的值直接替换%d
    
3.内存    
  程序：保存在磁盘上的可执行文件
  进程：运行在内存中的程序
  如果想让程序运行，则程序必须加载到内存中才可以运行
  1) 内组的组成
     每个程序都是虚拟内存，由内存条内存、磁盘空间、设备寄存器等组成。
     
  2) 内存分块
  参数段: argc argv  bash调用main函数时传入的数据
  数据段: 全局变量、静态变量、常量    
  堆栈段：堆 由malloc 或new
          栈 形参变量、局变量、表达式临时存储区
  代码段：所有的函数
  
  常量：保存不变的量 如 23 , "asdfa"
  变量：在运行中，内存中的数据可以发生改变的量 
        int a; a=23; //a是变量
  
  例：
  int a; //全局变量  在函数外定义 作用于所有函数内
  int max(int x,int y){ // x,y 形参变量
      int b=x>y?x:y;  // b称为局部变量 在函数内定义
                      // x>y?x:y 是表达式 运算临时分配内存
      return b;
  }  
  
  例：
  static int a; //全局静态变量
  int fun(){
      static int b; //局部静态变量      
  }                 
  注意：
    每个函数内的局部变量尽管名称相同，也不是同一内存，一个函数不能使用另一个函数内的变量
    局部变量和全局变量同名，当前使用的是局部变量，而不是全局变量。              
  
   
   (1)main函数的常见写法
   void main(){}  在编译时通常会提示返回类型
   int main(){}
   main(){}       //代表默认的返回类型为int
   int main(int argc,char **argv){} //企业用法
   参数 argc代表参数个数
        argv代表参数列表,或数组 
   int main(int argc,char **argv,char **env){} //很少用
   
   例：使用参数
   int main(int argc,char *argv[]){
       printf("--- %d\n",argc);
       printf("--- %s\n",argv[1]);
       printf("--- %s\n",argv[2]);
       printf("--- %s\n",argv[3]);
   }
   编译 gcc -o ls test.c
   执行 ./ls -a kajsdf
      
   2) {}代码块
   int x=1; //全局 程序结束时释放
   int main(int argc,char *argv[]){
       printf("%d\n",x);
       int x=2;
       {
          int x=12;
          {
             int x=36;
             printf("%d\n",x);
          } //释放了 36的x 
          printf("%d\n",x);
       } //释放的是12的x   
       printf("%d\n",x);
   }//释放的是2的x
             
   3)程序执行时内存的分配过程
   int max(int x,int y){
       return x>y?x:y;
   }
   int main(int argc,char **argv){
       int a=12;
       int b=23;
       int c=max(a,b);
       printf("---- %d\n",c);
   }
      


五.gcc编译的四个阶段及常用参数

   gcc是编译器(即释译工具)
   arm-linux-gcc 是arm的编译器
   arm-android-gcc 是android的编译器
   -o 指定生成的目标
   -E 预处理 即把所有的#的编译指令替换为标准C   
   1) 预处理  gcc -o test.i -E  test.c  //-E 预处理 -o 目标文件
   -S 编译为汇编   
   2) 汇编    gcc -o test.s -S  test.i   //-S 汇编,  将预处理后的*.i文件转换为汇编文件*.s
   -c 编译机器码
   3) 机器码  gcc -o test.o -c  test.s  //-c 将汇编文件*.s转换为机器语言*.o
   4) 可执行  gcc -o test  test.o      //-o 目标为可执行程序 .o为依赖的机器码文件

   三合一，直接生成.o
   gcc -o test.o -c test.c
   四合一，直接生成可执行
   gcc -o test test.c
   

   多文件的编程和编译
   main在一个.c
   其它函数同一类别或功能在一个.c中 如mplayer
   其它的.c要提供.h文件做接口
   
   1).h的写法
     #ifndef 宏名 //假如 宏名没有定义，则编译下面代码
     #define 宏名 //定义宏 
        扩展声明
     #endif       //结束编译条件
     
     宏名写法：头文件的名称大写 .变成 _
   
   2)声明和扩展声明
     (1)声明
      int max(int x,int y); //函数的声明    
      int main(int argc,char **argv){
          int a=12;
          int b=23;
          int c=max(a,b); //函数的调用
          printf("---- %d\n",c);
      }     
      int max(int x,int y){ //函数的定义
          return x>y?x:y;
      }
     
     (2)扩展声明
      static 修饰函数，代表这个函数只能在本文档中使用
      不用static修饰，代表全局函数，可以在任意的文件中调用。但是在编译时会找不到该函数，些时必须做生明。如果其它.c调用另一.c中的函数，是用扩展声明,声明的前面加extern
      extern int max(int x,int y); //扩展声明
        
    例：
      //fun.h
      #ifndef FUN_H
      #define FUN_H
      extern int max(int x,int y); //扩展声明
      
      #endif
      
      //fun.c
      int max(int x,int y){
          return x>y?x:y;
      }
      //test.c
      #include <stdio.h>
      #include "fun.h" //引入头文件
      int main(int argc,char **argv){
          int a=12;
          int b=23;
          int c=max(a,b);
          printf("---- %d\n",c);
      }
      编译 gcc -o test test.c fun.c
   
六.程序的调试

1.代码错误
  编译时出错
  根据提示，将编译错误一个个找出来
  找不到.c  则指定.c的目录
  找不到.h  有两种方法解决
     1)在 #include "目录/头文件"
        例：#include "./lib/fun.h" //引入头文件
     2)编译时用 -I 来指定头文件的位置
        gcc -o test test.c ./lib/fun.c -I./lib
  
  变量重复定义 重名
2.段错误
  两种情况
  1) 一个函数的参数需要的是内存地址，而给到的是其它类型
     scanf("%d %d",&a,b); //scanf用于输入，参数需要的是内存地址

  2) 定义了一个指针变量，而指针变量中没有赋地址值  
    int* p; //int*是类型，p是变量名,存地址的
    scanf("%d",p); //因为p中目前还没有保存地址
  
  例：
  int main(int argc,char *argv[]){
    int a=12,b=23;
    int* p=&a; //int*是类型，p是变量名,存地址的
    scanf("%d",p);
    int c=max(a,b);
    printf("---- %d\n",c);
  }
3.异常错误
  如 int a=23,b=0;
     int c=a/b; //不能除0 运行时出错
4.逻辑错误
  是条件判断出错导致程序可运行，但运行的结果不是想要的，结果错
  
两种方法找异常和逻辑错误
1.printf打印法

   int main(int argc,char *argv[]){
       printf("--------------- 1\n");
       int a=12;
       int b=0;
       printf("--------------- 2  a=%d,b=%d\n",a,b);
       int c=a/b;
       printf("--------------- 3\n");
       printf("---- %d\n",c);
       printf("--------------- 4\n");
   }
   程序员常用方法 如果2打印，而3未打印，则代表2与3之间出现错误
         
2.调试工具法
   编译时必须用 -g参数编译，然后用gdb调试，如下：
        gcc -g -o test test.c fun.c
        gdb ./test
   当进入gdb后可使用如下指令
        l [n][fun] 查看代码  
        例：  l 查看所有代码  
                 l 3 查看第三行周围的代码  
                 l max 查看max函数
        b [文件名:][n][fun] 设置断点  
        例：  b 3 在第三行设置断点  
                 b max 在函数max处设置断点
        r 从前向后运行  遇到断点处停止
        p 打印信号     
       
        n 单步执行 不会进入函数
        u 单步执行 可跳出循环
        s 单位步执行，可以进入函数内部 
           
        例：p a 打印变量a的值 
               p &a 打印a的地址
               p a+2 打印变量a加2后的值
        info break 查看断点信息
           
////////////////////////////////////////第二天////////////////////////
一、数据类型
    常量: 运行的过程中数据不可改变
    变量: 运行的过程中数据可被改变
    标识符: 如类型名、变量名、函数名
1、 整型
       long   4字节  0-  2的32次方 -1
                     - 2的31次方 - 2的31次方-1                     
       short  2字节
       int    无确定
       
       signed 有符号    代表最高位当符使用
       unsigned 无符号  代表最高位当数字使用
       
       常量  234  默认为int
             234L long类型
             234U 无符号int类型
             234UL 无符号长整型
       进制，通常用10进制
             二进制  无法表达  0b0010101010 
             十进制   123
             八进制   0123
             十六进制 0x123
            
             十进制转其它进制 用10进制数除以进制,余数是转换后的数，商继续除进制,又有余数向前排列，直到商为0止
             其它进制转十进制 用前面的位乘进制数，和后面的位相加，就变成了后面位的十进制，直到最后一个位计算结束
             0x162 -> (1*16+6)*16+2
             
       ？下面的数字哪些是长整型
       721387821387983  0L  0xFFFFFFFFFFF 01234234252341324
       0L是长整型,其它都默认int
       
       ?下面哪些常量的写法是正确的
       2341234  0x9fkw8sw 032913  0432
       032913 八进制中，逢8进一，所以不可能包含8以上的数
       0x9fkw8sw 八进制中，逢16进一，所以不可能包含16以上的数
              10 -> A      
       
       0b11111111
       0xff   每一位代表4位的2进制
       0377   每一位代表2位的2进制
       
       有符号和无符号内存结构
       所有的数据都是以补码方式存储
       原码 能够代表数据的2进制
       反码 2进制数取反的数
       补码 在反码基上+1  
        7      0b00000111   正整数 原码就是补码
       -7      0b00000111   //7
               0b11111000   //反码
               0b11111001   //补码 -7 也是 249
               
                 
       变量
         类型 变量名[=值];
         类型的作用，指定内存的大小，指定当前的变量保存的数据类型
         
         初始化：即分配内存的同时赋值
         int a; //定义变量的过程就是分配内存的过程 a 是内存名 &a是内存编号
         a=12;  //不是初始化                     
         int b=23; //初始化，分配内存同时赋值  =真正的意义是拷贝
         
       ?问下面都代表什么类型
       signed a; //省略了int
       int a;    //省略了signed
       unsigned int a; //无符号整型
               
2、 实型
       double  双精度  8字节  小数点后15-17位
       float   单精度  4字节  小数点后6位  
      
       常量
             2.3  默认为double
             2.3f 单精度
             2.3e+0  指数 2.3*10的0次方 
             
       问 2e+1 是不是整数?
          不是整型，默认double
       问 2e+1 是不是表达式?
          2e+i 错 因为这不是表达式的 是一个常量小数
          
       内存结构
 
            

3、 字符
       char 1字节 本质是无符号整型 0-255
       常量  'a'  一个字符  本质编码 即ASCII码
             '中' 是整型吗？错 汉字是2字节 不是一个字符，这种写法错
       字符：是用单引号括起来的一个符号
       字符串：用双引号括起来的字符序列，以\0结束
             "asdf" 有5个字符 \0也是其中的一个字符，但看不见
       
       转义符
       单引号 '\''  是一个字符
       双引号 '\"'
       tab键  '\t'  
       退格键 '\b'
       警铃   '\a'
       回车   '\r'
       换行   '\n'
       8进制  '\ddd'  必须是三个位 d代表一个8进制位的数
       16进制 '\xhh'  必须是2个位  h代表一个16进制位的数
       
       字符集
       ASCII 0-127数，代表要绘制的字符图片的编号 '\0'就是0编号 
              '\0' == 0==NULL
       
       GBK   中国大陆字符集
       BIG5  台湾 \香港、澳门、新加坡、美国
       uncode  utf-8    qt android等都使用utf-8字符集
               utf-16
               utf-24
               utf-32  
               
       'A' ==65 == '\x41' ='\101' == 0x41 == 0101
       
       字符的算术运算
       'A'+2;
       
       '8'+2; //56+2
        8+2;  //8+2
       "8"+2  //地址+2  字符串本身是第0个字符的地址  指令参数输入的是字符串
                        "asdf" 值是a所在内存的地址 

二、 类型转换
       long long 长长整型   8字节
       long double 长双精度 16字节
       
1、 自动转换的规则
       在表达式中，以高级别为准来自动转换
       char 
            short  
                   int   
                        long 
                        float         
                               double
       'c' +12; //最终结果是什么类型 是int  'c'先变为int 和12相加
       23f+12;  //最终 float先自动转为double 然后参与运算 
       'a'+'b'; //最终是int  char先自动变为int，然后参与运算
       'c'+32+(4e+1); //double类型
       int a=3.2;  //a内存的是3 自动转换 舍去了小数部分
       double b=3; //b内存的是3.0
                            
2、 强制转换
       格式 (类型)值;
       3/2;    //值是1  整数除整数，值为整数
       (double)3/2; //值是1.5  先将3强转为3.0，然后2也自动转为2.0 
       
       int a; //a内存名  &a 是内存地址
       int* p; //任意类型后在有* 都组合成新的类型，称为指针类型，用于存地址
       p=&a;  //p是int*类型的内存名,内存保存了a的地址
       
       地址前面加*，就是内存的名
       a 是内存名  &a  是地址   *&a 是内存名
                    p 是地址    *p  是内存名
                             
 
      int main(int argc,char **argv){
          int a; //申请了4字节，此时内存通过a可存整型
          a=23;
          printf("a=%d\n",a);
          int *p;//*只要前面有类型就和类型结合为int*
          p=&a;
          *p=0x2f12ff44;          
          printf("*p=%d\n",*p);//p是a的地址，所以*p就是a的变量名
          char *str=(char*)&a; //char*和int*同样是指针类型,区别char*所>存地址的内存用来存字符  int*所存地址的内存用来存整型
          //即然都是指针类型(即无符号整型)之间可以强转 转变的是内存所代
      表的含义
          *str='A';  //通过*str可存字符
          printf("*str=%x,a=%x\n",*str,a);
      }
      想表达两件事：
         1）强转 转的是类型所代表的长度、数据的格式
         2）一块内存可以存任意类型数据，要看此时内存用什么类型来代表的

      int a=1243;
      (double)a;  
      ?问a变成了什么数 
       a还是1243
       (double)a是一个新的内存空间，是表达式的临时存储区 里面存的是1243.0
       
      int *p=&a;
      char *str=(char*)p; 
      ?问把什么转换了
       是a中的数据吗？不是
       p是一个地址，代表整型的地址 
       (char*)p 表达式临时内存空间，存了地址值，代表了字符类型的地址
       所以通过*p（名）存整型
           通过*str(名)存字符
           
3、 字符串与数值之间的转换
    串转数
       int atoi(const char *nptr);
       long atol(const char *nptr);
       double atof(const char *nptr);
       参数 nptr 字符串
            返回类型 int 、long、double
       
       例：
       int main(int argc,char **argv){
           //字符串转整型
           int a=atoi(argv[1]); //atoi将字符串argv[1]转换为整型，赋给a
           printf("%d\n",a);
           int b=atoi("8");
           printf("%d\n",b);
           //字符转整型
           int c='8'-'0';
           printf("%d\n",c);
       }
    数转串
       字符串，即多个字符
       char str[256]; 
       //代表定义了256个字符 可以用来存字符串 str代表整个内存的地址
       
       
       int  sprintf(char  *str,  const  char  *format,  ...);
       参数： str 指定的内存地址 将转完的字符串保存在这个内存中
              format 含有格式符的字符串
                  %-md  整型
                  %-ml  长整型
                  %mu  无符号
                  %mo  八进制
                  %mx  十六进制
                  %mp  十六进制 前面有0x
                  %m.nf  单精度
                  %m.nlf 双精度
                  %mc  字符
                  %ms  字符串
                  m代表占多少个字符的宽度
                  .n代表占小数点的位数
                  -代表左对齐
              ... 用逗号分隔的值(常量、变量、表达式) 替换前面的格式符
       例：           
       int main(int argc,char **argv){
           int a=23;
           char str[256];
           sprintf(str,"%d",a); //将一个整型转成了字符串
           printf("%s\n",str);
           sprintf(str,"0x%x,0%o",a,a);//将一个整型转为16和8进制并组合成一个字符串
           printf("%s\n",str);               
           double b=3.13241324;
           sprintf(str,"%.2lf",b);
           printf("%s\n",str);       
       }
     
三、输入输出
 1. scanf用来输入数据 
    int scanf(const char *format, ...);
    参数：format同sprintf
          ...   代表内存地址

    int main(int argc,char **argv){
       int a; //&a
       scanf("%d",&a);
       printf("--- %d\n",a);
    }
    总结：两种方法数据从键盘进入程序
    
    int getchar(void);  //获取键盘中输入的一个字符
    char *gets(char *s);//获取键盘中输入的一个字符串

    int main(int argc,char **argv){
       char c; //存字符
       c=getchar(); //获取一个字符
       
       //char str[256]; //存符串
       //gets(str); //获取一个字符串  空格也是字符串的一部分
       int a; //&a
       scanf("%d",&a);
       
       char buf[256];
       double b;
       scanf("%s %lf",buf,&b);  //默认情况，空格是一个数据的结束
       printf("a=%d,buf=%s,b=%lf,c=%c,str=%s\n",a,buf,b,c,str);
    }
2.输出
    printf输出
    int  printf(const  char  *format,  ...);
    参数同sprintf

    例：    
    int main(int argc,char **argv){
        int a[23];
        scanf("%d",a);
        printf("--- %d\n",*a);//*a 就是 a]0]
    
        int b;
        scanf("%d",&b);
        printf("--- %d\n",b);
    
        char c[256];
        scanf("%s",c); //%s代表一串字符  s对应的是一个内存的地址
        printf("--- %s\n",&c[0]);//c本身是地址  ＆c[0]
    
        scanf("%c",c);
        printf("--- %c\n",c[0]);//c[0] 是变量名
    }
       
            
          
四、运算符
    单目：参与运算的就一个变量
    双目：参与运算的两个变量
    三目：参与运算的是三个变量
    算术运算符
       + - * / % ++ --
       - 单目运算符 取负
         -a; 
       + - * / % 双目运算
         a+b;
         注意：
         1. /  整数除整数，结果为整数； 不能除0
         2. %  两边必须是整数;  结果的正负由被除数决定
               12%7 ; 结果是周5   0为周日 
               -12%7; 结果是周-5  即-5+7 周2
               12%-7; 结果5    符号与除数无关
               7.0%2; 错 两边必须是整数
       ++ --  单目运算符 
         自加自减 
         int a=12;
         a++;  //结果13  相当于a=a+1 本身包含了赋值运算
       
       前置和后置,主要体现在表达式中
         ++a   //a先自加1 然后将加1后的值参与表达式运算
         a++   //a先参与表达式的运算，然后自加1
    
         
    赋值运算符
       = += -= *= /= %= 
       注意：
       1) =连续赋值
          int a,b,c,d;
          a=b=c=d=23;  //相当于a=(b=(c=(d=23))) 
                       //(d=23) ()代表是里面的表达式最后一次运算的结果 
          问下面的写法是否正确？
          int a=b=c=d=23; //错 原因是b,c,d没有被定义
          int b,c,d,a=b=c=d=23; //对
       2) +=
          int a=23;
          a+=1;  //相当于a=a+1               
          
       
    关系运算符
       >  >= < <=      == != 
         优先高         低
         
         关系运算符的结果是 真和假  0为假 非零为真(1)
       int a=23,b=10,c=5;
       a>b==c  先算a>b 结果是0
       a>b>c   错 电脑中不可以这样写
       
    逻辑运算符
       &&   ||   !
       && 与 两个都是真，则为真  ...和...  ... 并且...
       || 或 两个都是假，则为假  要么...要么...  
       !  非 真变假，假变真
       
       短路运算
       a && b   当a为假，则不运算b
       a || b   当a为真，则不运算b
       
       问，下面运算的结果是?
       int a=23,b=12,c=3,d=20;
       (a+=2) || (b=c+d++);
       printf("%d,%d,%d,%d\n",a,b,c,d);
       a+=2的结果是25,所以为真，所以后面 b=c+d++没有运算
       
       练习：计算输入的日期是否为闰年
               
      int main(int argc,char **argv){
          //int y=atoi(argv[1]);
          int y;
          scanf("%d",&y);
          printf("%s\n",(y%4==0 && y%100!=0 || y%4==0)?"闰年":"平年");
      }
    
    
    条件运算符  
    a?b:c
    	如果a是真，则结果为b,否则结果为c
    	int a=23,b=34,c=12;
    	a>b?a:b;
    	a>b?a:b>c?b:c; //右结合 相当于a>b?a:(b>c?b:c);
    	
    逗号运算符
      ,
      先算,号前面的表达式，再算后面的表达式，整个表达式运算结果为最后一次的结果
      int a=12,c=23;
      int b=(a++,c+=a++,--a);
      //a++后变为13,a又变为14, a又变为13，()的值是13 赋给了b
      a+b=c*2+=b; //错 赋值不能给常量和表达式赋值，只能给变量赋值
                  //(a+b)=((c*2)+=b)
      
    长度运算符
      sizeof(变量名或类型名) 用于计算内存的大小 单位是字节 是运算符
      strlen(内存地址)       用于计算字符串长度 单位是个数 是函数 遇\0结束
      字符串长度：\0前面的字符个数称为字符串的长度
      
      printf("%d\n",sizeof(int)); //4 代表用int类型分配的内存是4字节
      int a;
      printf("%d\n",sizeof(a)); //4 代表a的内存是4字节
      char buf[200];
      printf("%d\n",sizeof(buf)); //200 代表buf内存长度为200字节
      
      char buf[200]="abc";
      printf("%d\n",strlen(buf)); //3  buf中字符串的长度为3
////////////////////////////////////////第三天////////////////////////
       
    位运算符
1.    &   如果两个都是1 ，则为1
          通常用于清0
      例：ip地址
            192        168        1        12
          11000000  10101000   00000001  00001100
          11111111  11111111   11111111  00000000
        -----------------------------------------
          11000000  10101000   00000001  00000000
       
       特点：和1与运算，原数不变  和0与清零   
          
        int ip= 0xc0a8010c;
        int a=ip & 0xFFFFFF00;
      例：有一个寄存器4字节，第[6]位控制LED灯，低电平时通电
        如果填写这里面的数据
        
        int a;
        a=a & 0xFFFFFFBF;
        
      例：屏幕的一个象素点RGB565 去掉绿色，之后的颜色值
        0011111111101111  白色
        1111100000011111
        -----------------
        0011100000001111
        
        short pix=0x3fef;
        pix=pix & 0xf81f;
        
        
2.    |   如果两个都是0 ，则为0
        将数据合并一个数据
      
        
      例：ip地址 将12写入到IP地址中
            192        168        1        0
          11000000  10101000   00000001  00000000
      |                                  00001100
      -------------------------------------------
          11000000  10101000   00000001  00001100
                                             
      特点：和0或 不变   和1或变为1   
      
      int ip=0xC0A80100;
      ip=ip | 0x0C;
      
       
        例：有一个寄存器4字节，第[6]位控制LED灯，高电屏关闭灯
        如果填写这里面的数据
        
        int a;
        a=a | 0x40;
        
        
     
3.    ~   取反 0变1 1变0
      
      例：有一个寄存器4字节，第[6]位控制LED灯，低电平时通电
        如果填写这里面的数据
        
        int a;
        a=a & (~0x40); //0xFFFFFFBF;


4.    ^  异或 相同为0，不同为1
      加密、交换数据
      
  例：交换数据    
   a   7  00000111
   b   3  00000011
   ----------------
   a      00000100 4
   b   3  00000011
   ----------------        
   b      00000111 7
   a      00000100
   ----------------
   a      00000011
           
       int a=7;
       int b=3;
       a=a ^ b;
       b=a ^ b;
       a=a ^ b;
        
           
       特点：数a与数b异或,变成新的数，新的数再与a异或又变为b
          
    例：加密
        char str[]="Android";
        str[0]=str[0] ^ 0x4f;  //0e
        解密
        str[0]=str[0] ^ 0x4f;  //A
      
        
      
      
5.    <<  相当于*2
      >>  相当于/2
      左移 左侧溢出的抛弃，右侧补0
      右移 右侧溢出的抛弃，有符号 正 左侧补0
                                  负 左侧补1
                           无符号    左侧补0        
      
  
      例：将RGB565中的R的亮度值取出
      
      char r=(rgb565>>8 ) 0x F8;  
      
      0011111111101111  灰色 取出r的灯亮度
   >>8        00111111  后3位是原g灯的亮度
   &          11111000
   --------------------
              00111000  纯r灯亮度
      取出的灯亮值，在字节中占高位
      
      例：将r 0xee g 0x10  b 0x45写入到rgb565内存中
      char r=0xee
      char g=0x10;
      char b=0x45;
      
      short rgb565=((r>>3)<<11) | ((g>>2)<<5) | (b >>3) ;
           
              
                 
     例：有一个寄存器4字节，第[6]位控制LED灯，低电平时通电
        如果填写这里面的数据
        
        int a=寄存器;
        a=a & (~(1<<6)); //开
        寄存器=a;
        
                                          1 <<6
        00000000 00000000 00000000 01000000
     ~  11111111 11111111 11111111 10111111
     
     
     &  10101110 10110010 11010101 11110010
     ---------------------------------------
                                   10110010
                                   
                                                                        
       
        a=a | (1<<6); //关
         
        1 <<6
        00000000 00000000 00000000 01000000 
     |  10101110 10110010 11010101 10110010
        -----------------------------------
                                   11110010
                                   
           
     
     例：将r 0xee g 0x10  b 0x45写入到rgb565内存中
     图片格式     

     rgb555    前面一个位空rgb分别占5位
     rgb565    rgb分别占5位 6位 5位
     rgb888(rgb24) rgb分别占8位
     rgb32     前一个字节空(透明度) rgb分别占8位
     YUV 像机采集 和rgb有公式
     JPG libjpeb.a
     PNG libpng.a
     TIF 
     
     
    char r=0xee; //0x1D
    char g=0x10; //0x04
    char b=0x45; //0x08
    //1110100010001000 E888
    char rgb[2];
    rgb[1]=(r & 0xF8) | (g >>5);
    rgb[0]=((g <<3) & 0xE0) | (b>>3);
    printf("%x\n",*((short*)rgb));
    或
    *((short*)rgb)=((r & 0xf8)<<8) | ((g>>2)<<5) | (b>>3);
                                     (g & 0xfc) <<3)
                                     
    112009元人民帀
    11万->110000
    0.2009万->2009
    
///////////////////////////////////////////////////////////////
一、分支
    if  switch
    
1、if格式
    if (条件){//真与假 如果只有一条语句，则可省略{}
       语句
    }
    else if (条件){  //可省略
       语句
    }
    ....
    else{  //可省略
       语句
    }
    
    用途：根据条件决定执行哪些语句
    例：判断输入的年份是否为闰年
    int y;
    scanf("%d",&y);
    if (y%4==0 && y%100!=0 || y%400==0)
       printf("闰年\n");
    else
       printf("平年\n");
       
    
    例：输入学分，打印优良中差不及格
    int s;
    scanf("%d",&s);    
    if (s>100 || s<0)
       printf("输入错误\n");
    eles if (s>=90)
       printf("优\n");    
    eles if (s>=80)
       printf("良\n");    
    eles if (s>=70)
       printf("中\n");    
    eles if (s>=60)
       printf("差\n");    
    else 
       printf("不及格\n");
    
      
    if (80< s <100) //错   
    if (80< s && s <100) //对  
    if (s>90){ //对
        a++;
        printf("优\n");    
    } 
    if (s>90) //错
        a++;  
        printf("优\n");  //该语句不属于条件中的语句
            
    
2、switch
    格式
    switch(整型变量){ //int short long char  枚举
    case 常量:
         语句;
         break; //可省略,代表代码继续向下执行
    .......     
    default:
         语句;
         break; //可省略，不用break此时也结束了switch
    }
    break用来跳出switch和循环 
    首先变量和case后面的常量匹配(是否一样)，如果成功，则开始向下执行代码，如果在case无法找到匹配的值，则进入default,开始向下执行代码。
    在所有的case中，如果匹配成功，则不再继续匹配
    
    
    
    例:
    int a;
    scanf("%d",&a);
    switch(a){
    case 1:
        a+=3;
        break;
    case 2:
        a+=6;
    case 3:
        a+=1;            
    default:
        a-=4;
    case 4:
    case 6:
        a++;    
    }
    printf("%d\n",a);
    a输入  1    输出 4
           20   输出 17
           4         5
           2         6
    case 和default是标签
    
    练习：输入距今天的一个时间段(天数)，输出这个时间段结束的那天是周几(汉字)
    方法一：
    int w;
    char *week[]={"日","一","二","三","四","五","六"};
    scanf("%d",&w);
    printf("---今在是周%s\n",week[w%7]);
    方法二：
    int w;
    scanf("%d",&w);
    char*  str;
    switch((0+w)%7){
    case 0: str="日"; break;//字符串本身就是地址,地址存在了str变量中
    case 1: str="一"; break;
    case 2: str="二"; break;
    case 3: str="三"; break;
    case 4: str="四"; break;
    case 5: str="五"; break;
    case 6: str="六"; break;
    }
    printf("---今在是周%s\n",str);
    
    
    练习：今年是羊年，问29年后是哪一年?
    年份的顺序是鼠  牛  虎  兔  龙  蛇  马  羊  猴  鸡  狗  猪
                0    1   2   3   4   5   6   7   8   9  10   11
                            
/////////////////////////////////////////////////////////
一、 循环
      用途：根据条件重复执行代码
    
   例：1+2+3+4+5.....   
1、goto 跳转到标签的位置
     int main(int argc,char **argv){
         int i=0;//代表要加的数
         int sum=0;//代表最终的和
     LOOP: //标签    
         sum+=i++;
         if (i<10) goto LOOP; //i只要小于10就跳到前面重复执+
     
         printf("--- %d\n",sum);
     }
     注意：goto不能交叉使用
     
   
2、do ... while
   格式
     do {
     
     }while(条件); //如果条件为真，则跳到do的位置 
     注意: 结束后有分号 while和 }在一行上
           do 循环至少执行一次语句
      
 
    int main(int argc,char **argv){
        int i=0;//代表要加的数
        int sum=0;//代表最终的和    
        do{
          sum+=i++;
        }while(i<10);
        printf("--- %d\n",sum);
    }

   
   
3、while
   格式：
     while(条件){ //如果只有一条语句，则可省略{}
        语句
     }
     如果条件为真，则执行语句，先判断再执行
   

    int main(int argc,char **argv){
        int i=0;//代表要加的数
        int sum=0;//代表最终的和    
        while(i<10){
          sum+=i++;
        }
        printf("--- %d\n",sum);
    }

   
4、for循环
    格式
    for(初始化;条件;增量){
       语句;
    }
    初始化：不能被重复执行，所以不是循环体内的语句，相当于while前面的代码
    条件：  同while循环 如果为真，则进入循环体
    增量：  本质就是循环体内的最后一条语句
    
    例1:
    int main(int argc,char **argv){
        int i=0;//代表要加的数
        int sum=0;//代表最终的和    
        for(;i<10;){  //同while,注意多了两个;号
          sum+=i++;
        }
        printf("--- %d\n",sum);
    }    
    
    例2:
    int main(int argc,char **argv){
        int i,sum;
        for(i=0,sum=0;i<10;){  //同while,注意多了两个;号
          sum+=i++;
        }
        printf("--- %d\n",sum);
    } 
    例3:
    int main(int argc,char **argv){
        int i,sum;
        for(i=0,sum=0;i<10;sum+=i,i++);
        printf("--- %d\n",sum);
    } 
    
    练习：求1-100之间的能被3整除但不能被7整除的数的和
    两个问题：
      1.要注意条件用于做什么
          1-100是一个条件 i代表取值 用于循环
          i%3==0 && i%7!=0 用于选择执行求和
      2.哪些用于重复执行哪些是选择执行
          每个数都要判断，所以求和的条件是被重复执行
          i++ 也是被重复执行，所以不需要选择执行
      1)while
      int i,sum;
      i=1,sum=0;
      while(i<=100){         
         if (i%3==0 && i%7!=0){
            sum+=i;
         }
         i++;
      }    
      
      2)for 
      for(i=1,sum=0;i<=100;i++){         
         if (i%3==0 && i%7!=0){
            sum+=i;
         }
      } 
      3)goto 1
      int main(int argc,char **argv){
          int i,sum;
          i=1,sum=0;
          LOOP:
             if (i>100) goto OVER;
             if (i%3==0 && i%7!=0){
                  sum+=i;
             }
             i++;
             goto LOOP;
          OVER:
          printf("--- %d\n",sum);
      }
 
     4)goto 2
      int main(int argc,char **argv){
          int i,sum;
          i=1,sum=0;
          LOOP:
             if (i%3==0 && i%7!=0){
                  sum+=i;
             }
             i++;
             if(i<=100) goto LOOP;
          printf("--- %d\n",sum);
      }


5、循环跳转
    return 结束当前函数，如果在循环里面，同时结束循环
           如果在main函数中，可结束程序
    exit(0) 结束程序，在任何函数中或任何.c文件中都可结束程序
    
    break  结束switch和循环 不能用在goto中  向后跳出
    
    continue  向前跳到条件处。中止当前这一次的循环      
      
    
    int i;
    for(i=0;i<10;i++){
    }  
    循环后i变为10
    int i;
    for(i=0;i<10;i++){
       if (i==6) break;
    }  
    循环后i变为6  break时再写没有机会运行i++
    int i;
    for(i=0;i<10;i++){
       if (i==6) continue;
    }  
    循环后i变为10  continue相当于循环的} 先运行i++
    int i;
    for(i=0;i<10;){
       if (i==6) continue;
       i++
    }  
    循环为死循环 continue相当于循环的} 前面没有i++
    for(;;){} 死循环
    for(;1;){} 死循环
    for(i=1;i;i++){} 不是死循环
    while(1){} 死循环
    
    int i=0;
    while(1){
       if (i%3==2) break;  //结束循环
       i++;
    }
    
    练习：计算半为1-100之间的圆的面积，要求面积小于100
    分析:1-100之间取数为重复 i
         面积小于100 选择是否结束循环
    int i;
    double s=0;
    for(i=1;i<=100; i++){
       s=3.14*i*i;
       if (s>=100) break;
       printf("--- s=%lf\n",s);
      
    }
    
    练习：计算1+3+5+7.... n
    分析:1..n之间数 a代表要使用的数 要一个个拿到出来用，重复 循环
         a的变化规律
         思考1  a=i*2-1;  循环条件 i<n/2
         思考2  a=a+2;
     
    int main(int argc,char **argv){
        int a,n=atoi(argv[1]),s=0;
        for(a=1;a<=n;a+=2){
           //printf("--- a=%d\n",a); //测试
           s+=a;
        }   
        printf("--- s=%d\n",s);   
    }
      
    
    int main(int argc,char **argv){
        int i,a,n=atoi(argv[1]),s=0;
        for(i=1;i<=n/2;i++){
           a=i*2-1;
           //printf("--- a=%d\n",a); //测试
           s+=a;
        }   
        printf("--- s=%d\n",s);  
    }
 
    
    练习：计算1+1/3+1/5+1/7.... 1/n
    分析：递增 1 3 5.. fm+=2
                       fz=1
          要使用数  a= fz/fm             
          
      int main(int argc,char **argv){
          int fz,fm,n=atoi(argv[1]);
          double a,s=0;
          for(fz=1,fm=1;fm<=n;fm+=2){
             a=(double)fz/fm;
             //printf("--- a=%lf\n",a); //测试
             s+=a;
          }   
          printf("--- s=%lf\n",s); 
      }
    
  
    练习：计算1-1/3+1/5-1/7.... 1/n
     分析：递增 1 3 5.. fm+=2
                        fz=1  使用之后 fz=-fz
          要使用数  a= fz/fm      
    
          int main(int argc,char **argv){
              int fz,fm,n=atoi(argv[1]);
              double a=1,s=0;
              for(fz=1,fm=1;fm<n;fm+=2){
                 a=(double)fz/fm;
                 //printf("--- a=%lf\n",a); //测试
                 s+=a;
                 //----做准备-----------
                 fz=-fz;
              }   
              printf("--- s=%lf\n",s); 
          }
    
    练习  1+1+2+3+5+8+13+....
    思考：前两项和是第三项
          要使用的数   a  =a1+a2
          下次要使用的 a2和a1
              a1=a2
              a2=a
              
              
          int main(int argc,char **argv){
             int a=1,a1=0,a2=0,n=atoi(argv[1]);
             int s=0;
             for(;a<n;){
                //printf("----- a=%d\n",a);
                s+=a;
                //----为下次循环做准备
                a1=a2;
                a2=a;
                a=a1+a2;
             }
          
             printf("--- s=%d\n",s);   
          }
             
    
    练习  1+1/2+2/3+3/5+5/8+8/13+....
    分析1：分母 前两个分母之和等于第三个分母
          int main(int argc,char **argv){
            int a=1,a1=0,a2=0,n=atoi(argv[1]);
            double s=0;
            for(;a<n;){
               //----为下次循环做准备
               a1=a2;
               a2=a;
               a=a1+a2;  //a是分母
               //printf("-----a2=%d a=%d\n",a2,a); 
               //上一个分母保存在了a2中 分子就是上一次的分母
               s+=(double)a2/a;
            }
            printf("--- s=%d\n",s);  
         }
      
     分析2  当前的分母是前一个分子和分母的和
            当前的分子是是上一次的分母
            fz=1
            fm=1
            
            tmp=fm;
            fm=fz+fm;
            fz=tmp;
            s+=fz/fm
            重复，用循环
            
         int main(int argc,char **argv){
            double fz=1,fm=1,s=0,n=22;
            for(;fm<n;){
              s+=fz/fm;
              //printf("--- fz=%lf,fm=%lf\n",fz,fm);
              //----准备工作
              double tmp=fm;
              fm=fz+fm;
              fz=tmp;
            }
            printf("--- s=%d\n",s);  
         }
           
    
    练习  求s=a+aa+aaa+aaaa+.... 的值，其中a是一个数字。
          例如2+22+222+2222+22222(此时共有5个数相加)
    分析：要使用的数 b 和a什么关系
              b  = b   *10+a
            本次  上次        
      
          int main(int argc,char **argv){
             int b=0,a=2,i,n=3,s=0;
             for(i=0;i<n;i++){
               b=b*10+a;
               //printf("--- b=%d\n",b);
               s+=b;
             }
             printf("---- s=%d\n",s);
          }

      
      
  
6、循环嵌套
     
   在循环体内，有循环
   
   解决的问题矩阵(有行和列)、多轮多次的数据
   
   例：乘法口吷
   1*1=1
   1*2=2 2*2=4
   ............ 9列 9行
   
   分析：i代表行号  <=9行
         j代表列号  <=i列
         
         int main(int argc,char **argv){
             int i,j;
             for(i=1;i<=9;i++){//i行
                 for(j=1;j<=i;j++){ //列
                    printf("%d*%d=%-2d ",j,i,i*j);
                 }
                 //此处是一行的结束
                 printf("\n");
             }
         }
  
  练习 打印如下图形
     *
    ***
   *****
  *******
 *********
***********       
  分析 这个图形由n行组成  用i代表行号
       每一行由" "和"*"组成  共分为两部分
       1)空格规律
         i  有  n-i个空格
         所以有多少个空格就重复输出" "多少次  所以循环
       2)*的规律
         i  有  i*2-1个 *
         所以有多少个* 就重复输出"*"多少次  所以循环           
         
     int main(int argc,char **argv){
        int n=atoi(argv[1]);
        int i,j;
        for(i=1;i<=n;i++){
          //输出空格
          for(j=1;j<=n-i;j++) printf(" ");
          //输出＊
          for(j=1;j<=i*2-1;j++) printf("*");
          //--是一行的结束
          printf("\n");
        }
     }
 
     
     
  练习：判断101-200之间有多少个素数，并输出所有素数 
  分析：
      判断一个数是否为素数
      需要将2- num-1之间来除这个数，看是否能除尽的
      ？只要被一个数除不尽就是素数吗？
      如果设置一个标记，先假设是素数，如果遇到一个除尽则更改记
      
      又分析需要判断101-200之的数，所以需要运行100次（轮）
 
 
       int main(int argc,char **argv){
         int i,j;
         for(i=101;i<=200;i++){ //i 轮 或理解为第i个数
             //判断是否为素数 
             int sign=1; //先假设是素数 ***重点理解
             for(j=2;j<i;j++){ //j代表要除的数
                if (i%j==0) {
                    sign=0;
                    break;
                }
             }
             //判断完之后输出
             if (sign==1){
                 printf("%d ",i);
             }
         }
      }       
     
  问？用什么方法能同时结束多重循环
  方法一：运用标号
      int main(int argc,char **argv){
          int i=0;
          printf("---- start\n");
          while(1){
             while(1){
                 while(1){
                    if (i==10) goto A;
                    i++;
                 }
             } 
          }
      A:
          printf("------over\n");
          return 0;
      }
  方法二：运用标记      
      int main(int argc,char **argv){
          int i=0,sign=1;
          printf("---- start\n");
          while(sign){
             while(sign){
                 while(sign){
                    if (i==10) sign=0; 
                    i++;
                 }
             } 
          }
          printf("------over\n");
          return 0;
      }
         
     

///////////////////////////////////////////////////////////////////////////////////////////////
1. 输入一个数，位数不限，判断是否为回文
2. 输入一个数，判断是几位数，并逆序输出 
3. 输入某年某月某日，判断这一天是这一年的第几天 
4. 打印出所有的“水仙花数”，所谓“水仙花数”是指一个三位数，其各位数字立方和等于该数本身。例如：153是一个“水仙花数”，因为153=1的三次方＋5的三次方＋3的三次方。
5. 输入两个正整数m和n，求其最大公约数和最小公倍数。
    如 12和8  最大公约数是4 最小公倍数 12*8/4 = 24
6. 求1+2!+3!+...+8!的和
7.  一球从100米高度自由落下，每次落地后反跳回原高度的一半；再落下，求它在
　　　第10次落地时，共经过多少米？第10次反弹多高？
8.  猴子吃桃问题：猴子第一天摘下若干个桃子，当即吃了一半，还不瘾，又多吃了一个
　　　第二天早上又将剩下的桃子吃掉一半，又多吃了一个。以后每天早上都吃了前一天剩下
　　　的一半零一个。到第10天早上想再吃时，见只剩下一个桃子了。求第一天共摘了多少。
9. 古典问题：有一对兔子，从出生后第3个月起每个月都生一对兔子，小兔子长到第三个月
　　　后每个月又生一对兔子，假如兔子都不死，问每个月的兔子总数为多少？



//////////////////////////////////////////////////////////
数组
   数组：是相同类型数据的集合，内存空间连续
   相同类型数据:数据类型相同的变量或常量
   集合:多个
   内存空间连续:内存的地址是连续
   
   整型之间地址相差4字节
   字符之间地址相差1字节
   
1、格式：
     类型 数组名[变量个数][={值}];
     
     int a[12];//定义了12个变量 a是数组名,每个变量的名a[i]
     i是下标、索引、序号 0- n-1
     
     int a[12];
     a[0]=12;  这样赋值，是重复操作 用循环 下标不同，所以可以用变量表达下标
     a[1]=23;
     a[2]=34;
     .....
     
     
     int i; //代表下标
     int a[12];
     for(i=0;i<12;i++){
        //scanf("%d",&a[i]); //或下面写法
        int tmp;
        scanf("%d",&tmp);
        a[i]=tmp;
     }
     [] 如果在定义数组时，里面的数据代表个数
        如果在使用数组元素，里面的数据代表下标
        
     例：输入一个字符串，问是否是回文    如 12321、abcba
        
     ?定义数组时，元素个数是否可以用变量、是否可以宏
     int a[n]; //定义变量时，元素个数只能用常量
     ?字符串的本质是什么，都可以存在哪个存储区
     用双引号括起来的字符序列，以\0为结束
     用双引号括起来是字符串常量，存在数据段
     在栈区，则不需要用双引号，是每一个字母存在一个连续的内存空间中。以\0结束 所以，字符串本质是字符数组
     
                
    函数 
     int strlen(char *str)  //计算字符串长度 即\0前面的字符个数
     int strcpy(char *dst,char *src) //将src拷贝到dst中
     
     0 == '\0' == NULL != '0'
     NULL 代表地址
     '\0' 代表字符
      
     
    输入字符串
     #include <stdio.h>
     #include <stdlib.h> //melloc
     #include <string.h> //memcpy
     
     int main(int argc,char **argv){
         int i;
         char str[256];
         //0输入字符串
         /* 一个一个的输入
         for(i=0;i<256;){
            char tmp;
            scanf("%c",&tmp);
            if (tmp=='#') {
                str[i]=0;
                break;
            }
            else if (tmp=='\n') continue; 
            str[i]=tmp;
            i++;
         }
         */    
         //1输入字符串
         /*连续输入
         for(i=0;i<256;i++){
            scanf("%c",&str[i]);
            if (str[i]=='\n') {
               str[i]='\0';
               break;
            }
         }
         */
         //2输入字符串
         /*连续输入 
         scanf("%s",str);
         */
         //3输入字符串
         /*通过指令参数输入
         for(i=0;i<256;i++) {
            str[i]=argv[1][i];
            if (argv[1][i]=='\0') break;
         }
         */
         //4输入字符串 
         strcpy(str,argv[1]);
         printf("--- %s\n",str);
     
     
         return 0;
     }
   分析：存一个字符串的数组，是字符类型
         字符串需要输入，长度不能确定，数组元素的个数应该大一些
         如何判断字符个数,\0前面的字符个数就是字符串的长度
         int main(int argc,char **argv){
             int i,n,sign=1;
             char str[256];
             scanf("%s",str);
             //for(n=0;n<256;n++) if (str[n]==0) break;
             n=strlen(str);
             for(i=0;i<n/2;i++){
               if (str[i]!=str[n-1-i]) {
                   sign=0;
                   break;
               }
             }
             if (sign==1) printf("是回文\n");
             else printf("不是回文件\n");
             return 0;
         }
                 
    
2、数组的初始化 
     初始化：即分配内存的同时赋值 
     int a[12]={12,32,435,123,32,32,43,23,34,22,43,11};
                0  1   2   3   4  5  6 7   8  9 10 11
     char s[5]={'a','b','c','d',0};
     //省略了元素个数，默认是后面值的个数
     int a[]={12,32,435,123,32,32,43,23,34,22,43,11};
     char s[]={'a','b','c'}; //字符数组3， 字符串长度为未知 
     //少写了元素值
     int a[12]={12,32}; //其它的值都默认为0
     char s[5]={'a',56};  //其它的值都默认为0 字符串长度2
     //字符数组独有的初始化方法
     char s[5]={"asdf"}; //字符串长度为4  数组是5
     char s[5]="asdf"; //同上
     char s[]="asdf";  //数组是5 字符串长度为4
     
3、数组名和地址
      数组名的本质，是第0个元素(首元素)的地址
      int main(int argc,char **argv){
          int a[6]={1,2,3,4,5,6};
          printf("%d,%p,%p,%p\n",a[0],&a[0],&a[1],a);
      }
      每个数组元素之间地址差4字节(int)
      
      地址+1  代表地址值为  地址 加 1*sizeof(int)字节
      a+0 是a[0]的地址
      a+1 是a[1]的地址 
      a+2 是a[2]的地址
      .....
      int main(int argc,char **argv){
          int a[6]={1,2,3,4,5,6};
          printf("%d,%p,%p,%p,%p\n",a[0],&a[0],&a[1],a,a+1);
      }
      
      a[i]的地址 &a[i]或a+i
      (a+1)[2]   //相当于a[3]
      [] 代表地址向后偏移再取值
      
       
4、二维数组的定义
      一维数组是(数据)的数组，每个元至少是一个数据 
      多数组是(数组)的数组，每个元素是一个数组
      
      格式
         类型 数组名[数组的个数][元素个数]
         
         int a[2][5]; //a 二维数组名 包含2个一维
         int b[3][5][6]; //3个平面  5 个线  6个点
         int c[8][3][5][6]; //8个立方 3个平面  5 个线  6个点
         
      例
         int a[4][5]; //4个一维  每个一维5个元素
         a    //二维数组名 是二维数组第0个元素地址 即一个一维数组的地址
         a[i] //一维数组名 是一维数组第0个元素地址 即一个整型的地址
         a[i][j] //第i个一维数组中的第j个变量名        
         
      例：
         int a[5];
         a+1; //是a[1]的地址 所以a+1是整数的地址
         (a+1)+1; //是从a算起的第2个元素的地址，
                  //也是从a+1算起的第1个元素地址
         (a+1)[1];//是从a算起的第2个元素的变量名(值)
                  //也是从a+1算起的第1个元素变量名(值)
      例：
         int a[5][4];
         a有5个元素，每个元素都是一个数组，一维数组中有4个元素
         a是数组名
         a+1  //是a[1]的地址 所以a+1是数组的地址            
         (a+1)+1;  //是从a算起的第2个数组(行)的地址，
         (a+1)[1]; //是从a算起的第2个数组(行)的名
         又分析，一维数组名是一维数组的首地址
         所以(a+1)[1]是第二行的首地址，即第2行第0列整数的地址
      

5、二维数组的本质
      二维数组本质是一维数组
      i=k/m
      j=k%m
      k=i*m+j
      
  1)用二维来表达一维数组
      int main(int argc,char **argv){
          int a[12]={6,3,4,5,11,7,8,9,10,1,2,12};
      
          int i,j;
          for(i=0;i<3;i++) {
             for(j=0;j<4;j++){
                 printf("%d ",a[i*4+j]);
             }
          }
      }
  2)用两重循环操作二维数组
      int main(int argc,char **argv){
          int a[3][4]={6,3,4,5,11,7,8,9,10,1,2,12};
      
          int i,j;
          for(i=0;i<3;i++) {
             for(j=0;j<4;j++){
                 printf("%d ",a[i][j]);
             }
          }
      }
    
   3)用一重循环操作二维数组
      int main(int argc,char **argv){
          int a[3][4]={6,3,4,5,11,7,8,9,10,1,2,12};
      
          int i,j,k;
          for(k=0;k<12;k++){
              printf("%d ",a[k/4][k%4]);
          }
      }
      
      或
      int main(int argc,char **argv){
          int a[3][4]={6,3,4,5,11,7,8,9,10,1,2,12};
      
          int i,j,k;
          for(k=0;k<12;k++){
              //printf("%d ",a[0][k]);
              printf("%d ",*(a[0]+k));
          }
      }
            

6、二维数组的初始化
   //把二维当成一维数组
   int a[3][4]={1,2,3,4,5,6,7,8,9,10,11,12}; 
   int a[][4]={1,2,3,4,5,6,7,8,9,10,11,12}; //必须指定列数 
   int a[][4]={1,2,3}; //默认1行 4个整型 1个为0
   //把二维当成二组
   int a[3][4]={{1,2,3,4},{5,6,7,8},{9,10,11,12}}; //{}为一个组
   int a[][4]={{1,2},{6,7,8},{9}};
              //a[0][2和3]为0   a[1][3]为0  a[2][1、2和3]为0
   //字符数组
   char a[3][4]={'1','2','3'}; //a[0][0,1,和2]都填数，其它默认为0
   char a[3][4]={"123"}; //a[0][0,1,和2及3]都填数，其它默认为0
   char a[][4]={"123","ad","YYZ"};
   
   例：分析，下面的代码打印结果
   char a[][4]={"1234567","bd","ggg"}; 
                 0123012   01  
   for(i=0;i<3;i++){
       printf("%s\n",a[i]);	
   }              
   //1234bd
   //bd
   //ggg
   
   练习：
     定义一个一维数组，存放12个整型、把这12个数据排序
        int a[]={4,3,7,2,1,9,78,5,76,34,6,90};
        int i/*第几轮*/,j;/*其它人*/
        for(i=0;i<12;i++){
           for(j=i+1;j<12;j++){
              if (a[i] > a[j]){
              	 int tmp=a[i];  // a[i]=a[i]^a[j];
              	 a[i]=a[j];     // a[j]=a[i]^a[j];
              	 a[j]=tmp;      // a[i]=a[i]^a[j];
              }	
           }	    	
        }
        for(i=0;i<12;i++) printf("%d ",a[i]);

     定义一个二维数组，存放4个字符串、把这4个字符串排序
         字符串大小比较，有两种方法
         1)一个字母一个字母的比
         2)用函数 int strcmp(char *str1,char *str2)
                  返回值 <0 前面小
                         =0 一样大
                         >0 前面大
                          
        char str[4][256];
        char tmp[256];
        int i;
        for(i=0;i<4;i++) scanf("%s",str[i]);
        for(i=0;i<4;i++){
           for(j=i+1;j<4;j++){
              if (strcmp(a[i],a[j])>0){
              	 strcpy(tmp,a[i]);
              	 strcpy(a[i],a[j]);
              	 strcpy(a[j],tmp);
              }	
           }	    	
        }
        for(i=0;i<4;i++) printf("%s ",a[i]);     
    
        "abcd"
        "abcde" 大 '\0' <'e'
        "abcd"
        "z"     大 'a' <'z'
        ""
        "0123"  大 '\0' <'0'
               
     
/////////////////////////////////////////////////////
函数
    什么时候用函数?
    1)代码复杂时，按着功能把代码分为小块，用函数实现
    2)重复的代码，用函数
    3)做接口用函数
    
    定义格式:
    返回类型 函数名(形参列表){
       return 返回值;
    }
    
    调用格式:
    函数名(实参列表);
    
    函数声明:
    返回类型 函数名(形参列表);

    函数定义，用来实现函数，占用程序内存(代码) 
    函数的调用，是利用函数来执行代码，获取计算的结果
    函数声明，例main调用max函数，如果max在main的后面定义，则编译时，main会找不到max函数，则可以在main函数之前声明max函数。
     
    如果思考编写函数?
    把函数比喻为一个工厂，
    研究工厂的产口是什么类型(返回类型)
    工厂的名称 xxxAaaa，xxx_aaaa 与变量起名的方法相同。函数名尽可能的表达出该函数的功能。
    形参,理解为是工厂原材料的通道。实参是原材料
    实参是具体的值，表达式、常量、变量。用来给形参赋值，而形是变量。
    产品就是计算的结果。就是返回的值
    return就是送货员。如果返回的值是void,则不玩需要返回计算的结果。
    
    return本质，是结束函数。如果在main函中结束程序 值返回给系统。
    exit(值) 值返回给系统
    在linux中，通常返回0代表函数执行成功，-1代表执行失败。否则代表是运行（计算）的结果。
    
（一）函数简化程离逻辑 
    复杂代码用函数、重复代码用函数
      
    例：已知今天是2015年12月20号，周日，问输入一个日期是周几。
    分析：如果要计算周几，则需要知道天数差,7周期 用%
          如果计算天数差 能否算出输入的日期到公元1.1.1的总天，如果计算总天数，把前面整年的加起，把整月加起来，把日加起来。 则今天公元1.1.1的算法同上
          用两个总天数相减
    
          总天数的计算重复使用，所以写成函数
          判断闰年的需要频繁使用，所以也写成函数
          
    接下来思考每部分如何实现
                
    #include <stdio.h>
    #include <string.h>
    #include <fcntl.h>
    
    int isReyear(int y){
        return y%4==0&&y%100!=0||y%400==0;
    }
    
    int days(int y,int m,int d){
        int i, months[12]={31,28,31,30,31,30,31,31,30,31,30,31};
        //前面年份总天数
        for(i=1;i<y;i++) d+=isReyear(i)?366:365;
        //前面月份总天数 
        for(i=1;i<m;i++) d+=months[i-1];
        if (m>2 && isReyear(y)) d++;
        return d;
    }
    int main(int argc,char **argv){
        char wstr[][4]={"日","一","二","三","四","五","六"};
        int y,m,d;
        scanf("%d %d %d",&y,&m,&d);
        int diff=days(y,m,d)-days(2015,12,20);
        int w=((diff%7)+7)%7;
        printf("输入的日期是 周%s\n",wstr[w]);
    }
    
    
    例：在一个终面的平面上，绘制出一个海螺图案。图案如下计算
    先绘一个半圆，半径为2，再以这个半圆的切线位置画另一半圆，半径为4，以此类推，则形成的图案为一个海螺图
    
    分析：画圆  函数  终端都是打印字符，所以 以打印字符当成一个平面，涉及行和列，二维字符数组
    平面的坐标就是二维数组的行和列下标值 找到要画点的下标，改这这个点的字符变量的值
    
    打印 函数
    
    数组的清零3种
    memset(地址,0,长度);
    bzero(地址，长度)
    int a[30][30]={0};
    
    为了能打印出来，数组中不能填0 填" ."
          
     #include <stdio.h>
    #include <stdlib.h>
    #include <string.h>
    #include <math.h>
    
    #define W 130
    #define H 130
    char buf[H*W];
    
    void print(char buf[]){
         int i,j;
         for(i=H-1;i>=0;i--){
            for(j=0;j<W;j++) printf("%c",buf[i*W+j]);
            printf("\n");
         }
    }
    //x0 y0是圆心点 r半径  a1 a2是起始和结束的角度
    int drawcirle(int x0,int y0,int r,int a1,int a2){
         int x,y,a;
         for(a=a1;a<=a2;a++){
            x=x0+r*cos(3.14*a/180); // 2 pi /360 == l/a
            y=y0+r*sin(3.14*a/180);
            if (y <0 || y>H || x <0 || x>W) return -1;
            buf[y*W+x]='*';
         }
         return 0;
    }
    int main(int argc,char **argv){
        memset(buf,'.',W*H);
        int x0=60,y0=60,r=6,a=180;
        int sign=-1;
        while(1){
           if (drawcirle(x0,y0,r,a,a+180)==-1) break;
           sign=-sign;
           x0=x0+sign*r;
           r*=2;
           a=(a+180)%360;
        }
        print(buf);
        int i,j;
    
    }
       
  练习：计算一个数组中，最大值和最小值的差  
    
     //int max(int a[],int size){//int[]是类型，a是数组名 是地址,在形参的位置是变量
     int max(int* a,int size){//int[]是类型，a是数组名 是地址,在形参的位置是变量
         int i,tmp=a[0];
         for(i=0;i<size;i++) if (tmp<a[i]) tmp=a[i];
         return tmp;
     }
     
     int min(int* a,int size){//a是数组名 是地址,在形参的位置是变量
         int i,tmp=a[0];
         for(i=0;i<size;i++) if (tmp>a[i]) tmp=a[i];
         return tmp;
     }
     
     int main(int argc,char **argv){
         int b[12]={32,12,4,32,5,4,65,7,876,8,56,3};
         int diff=max(b,12)-min(b,12);
         printf("%d\n",diff);
     }
         
    
（二）函数做接口
    接口，是程序为功能模块，在模块与模块之间进行调用函数称为接口
    .h文件，是函数库的头文件 用于定义类型、宏、扩展声明函数或变量
    .c文件，称为源码文件，用来实现函数
    .s文件，称为汇编源码
    
    .a或.so文件，称为库文件，是对.c文件进行编译获得的
    .a 静态库 被编译到程序内部，编译完后可执行程序变大，本身在程序内部，所以执行时直接来调用。 
    .so动态库 没有被编译到程序，编译完后可执行程序小,执行时从系统/lib中去找这个库
       
 1.变量的分类
     int b; //全局变量
     static int c; //全局静态变量
     int main(int argc,char **argv){
        int a; //局部变量
        static int d; //局部静态变量
        a=5;
        printf("--- %d\n",a);
     }    
    
    
    参数段: main函数的参数内存空间
            程序加载时分配，程序关闭时释放
            
    数据段：内存程序加载时分配，程序关闭时释放
            常量  字符串常量 内存只读
            全局(自动)变量   auto 通常省略 可以通过扩展声明用于其它.c中
            全局静态变量     static  只能在本文档中.c使用
            局部的静态变量   static  只能在当前函数内使用，其它函数不可使用
                             虽然在函数内定义，但不是调用函数才分配内存
            
              例：void fun(){
                    int i=0;
                    static int j=0;
                    printf("--- %d,%d\n",i++,j++);
                  }
                  int main(){
                    int i=0;
                    for(i=0;i<10;i++){
                       fun(); //函数调用
                    }
                  }                       
    堆栈段
      栈区 内存在定义变量时分配，作用域结束后释放
           局部变量 函数内   执行定义变量时分配
           形参变量 函数名后 函数被调用时分配
           表达式
           
           int a=12;
           void fun(int b){//同一作用域内不可以有同名变量
              printf("---0 %d\n",a); //12
              int a=22;
              { //代码块,每一个代码块就是一个作用域
                 int a=23;
                 {
                    {
                       int a=34;
                       printf("---1 %d\n",a);  //34
                    }
                    printf("---2 %d\n",a); //23
                 }
                 printf("---3 %d\n",a);  //23
              }
              printf("---4 %d\n",a); //22
           }
           int main(){
           
           }
      
      堆区
           mew    C++   自动调用构造函数,申请内的内存，需要手工释放 delete
           malloc C,C++ 不会调用构造函数,申请内的内存，必须手工释放 free
           
           int main(){
               //malloc申请的内存没有名字 返回的是内存编号 void*
               int* p=(int*)malloc(4);//4字节
               *p=12;
               p[0]=23;
               
               int* p1=(int*)malloc(4*12);//48字节 
               for(i=0;i<12;i++) p1[i]=i;
               
           }
           
           任何类型+* 新类型，称为指针类型，指针类型变量用来存地址
           *+任何地址 变量名,即内存名，代表内存中存储的数据
           
           数组名就是内存地址 是常量
           内存地址就是数组名 是变量
     代码段
        存机器码，就是函数，所以函数有内存地址
        函数名就是函数的地址
        用来存储函数地址的变量称为函数指针类型变量
        与要保存的函数有关，例
        int max(int x,int y){//一个整型的返回类型，两个整型形参
            return x>y?x:y;
        }
        int main(){
            //int (*p)(int,int)=max(23,12); //错  
            //int *p(int,int)=max; //错 p是函数名 返回int*类型
            
            int (*p)(int,int)=max; //将max存储在p变量中
            //int (*)(int,int) 是函数指针类型  p是指针变量
  
            int a=p(12,23); //计算的结果赋给a 
            
        }   
        
        函数名是地址            是常量
        函数指针变量 就是函数名 是变量
              
        函数调用 
            函数地址(实参);
           
    
    总结:变量分类
        全局
           自动全局  auto
           静态全局  static
        
        局部
           自动局部  auto      //栈
           静态局部  static    //数据段
           寄存器变量 register //不使用内存空间，直接用寄存器
   //-----------------------------------------------------------        
2.函数扩展声明
    模块:按功能单独实现具有特定功能的代码块.
    模块与模块之间的衔接称为接口。接口是扩展声明的函数
    三种接口类型：
    面向过程编程：过程就是函数
    面向结构编程：结构体的成员函数地址
    面向对象编程: 对象就是类类型的变量，类的成员函数
    
    
    函数定义
        返回类型 函数名(形参列表){
           return 值;
        }
    函数声明
        返回类型 函数名(形参列表);
          
        用途，是编译时，提醒编译器
        例：
        int max(int x,int y);//声明
        int main(){
            int a=max(23,12);
        }
        int max(int x,int y){//定义
            return x>y?x:y;
        }
    函数指针
        返回类型 (*变量名)(形参列表);
        
        int main(){
            int max(int x,int y);//声明
            int (*pmax)(int x,int y)=max; //指针变量  定义变量
            int a=pmax(23,12); //函数调用
        }
        int max(int x,int y){//定义
            return x>y?x:y;
        }        
    
    
    扩展
        一个函数声明在当前的文档内，并且在调用前声明。只能用于当前文档
        static 只能用于当前文档
        auto   可扩展到其它文件中使用
        普通的声明没有扩展作用，声明的前面用extern 扩展
        
    
        接口（面向过程）
        .h 是头文件，用于定义数据类型，宏定义，扩展声明的函数或变量
        .c 源码，实现函数
        
        例：多文件编程
        #ifndef 如果宏没有被定义，则编译下面的代码
        #endif  判断结束
        
       //fun.h
       #ifndef FUN_H  //防止重复编译
       #define FUN_H 
       typedef int* PINT;      
       extern int max(int x,int y); // max
       extern int sub(int x,int y); // -       
       #endif
        
       //fun.c
       #include <stdio.h>
       #include <errno.h>
       #include "fun.h"
       int max(int x,int y){
           return x>y?x:y;
       }
       int sub(int x,int y){
           return x-y;
       }
       
       //test.c
       #include <stdio.h>
       #include "fun.h"       
       int main(int argc,char **argv){
          int a=max(23,34);
          printf("---- %d\n",a);       
       }
       
       gcc -o aaa test.c fun.c 
       
       <> 从/usr/include 中找头文件
       "" 从./目录中开始找头文件
       
       不对外扩展声明的写成静态，扩展声明的不能写成静态
       
 

3.函数递归
    递归：能解决所有循环的问题，但树的问题用循环无法解决，只能递归
    递归时，在函数中定义的变量，不能及时释放，消耗资源
    
    10+(9+(8+(7+(6+(5+(4+(3+(2+(1)))))))))

    分析: 循环结束的条件 i=10  i==1结束
    int main(){
    	  int i,sum=0;
    	  for(i=10;i>0;i--){
    	  	 sum+=i;
    	  }
    }	

    递归：用函数直接或间接的调用自已
          两种情况 递推、递归
    分析：找到一个条件，不再调用自已就是递归的结束
    int add(int n){
    	  if (n==1) return 1;
    	  return n+add(n-1);
    }    	
    int main(){
    	  int sum=add(10);
    }	   
    10+add(9)
       9+add(8)
         8+add(7)
           ....
                2+add(1)
                   1
                 
    利用递归方法求5!  
    5*(4*(3*(2*(1))))  
    int mul(int n){
    	  if (n==1) return 1;
    	  return n*add(n-1);
    }    	
    int main(){
    	  int sum=add(5);
    }   
      
    
    1+(1/2+(2/3+(3/5+(5/8+(8/13))))))
 
    double add(int fz,int fm){
          if (fm==13) return 1.0*8/13;
          return 1.0*fz/fm +add(fm,fm+fz);
    }
    int main(){
          double sum=add(1,1);
          printf("%lf\n",sum);
    }
    
    1-(1/2+(1/3-(1/4+(1/5-(1/6)))))
    
    double add(int fz,int fm){
    	  if (fm==6) return 1.0/6;
    	  return 1.0*fz/fm+add(-fz,fm+1);    	
    }
    
    
    
0 0 1+(1+(2+(3+(5+(8+(13+(21)))))))
    int add(int a1,int a2){
    	 int a;    	 
    	 if (a1==0 && a2==0) a=1;
    	 else a=a1+a2;
    	 if (a==21) return 21;
    	 return a+add(a2,a);    	 
    }
    
    
    
    利用递归函数调用方式，将所输入的5个字符，以相反顺序打印出来 
    "a(s(d)))"
    
    void print(char str[],int i){
    	   if (i==strlen(str)) return;
    	   print(str,i+1);
    	   printf("%c",str[i]);
    }  
    编写函数，计算一个数的8进制的值
    
    void print(int a){
    	 if (a==0) return;
    	 print(a/8);
    	 printf("%d",a%8); 
    }
    
    
    
    有5个人坐在一起,问第五个人多少岁？他说比第4个人大2岁。问第4个人岁数，他说比第3个人大2岁,问第三个人，又说比第2人大两岁。问第2个人，说比第一个人大两岁。最后问第一个人，他说是10岁。请问第五个人多大？
    
    5  4   3  2  1
    2+ (2+(2+(2+(10))))
    
    int age(int n){
    	  if (n==1) return 10;
    	  return 2+age(n-1);
    }
    
    下面代码具有哪些问题？
    int i;
    for(i=0;i<12;i++){
      double a=2.6E+i;  //错 
      printf("%lf\n",a);
    }
    下面代码具有哪些问题？
    long d=0xffffffffffffffL; //错 4字节
    
    int a=0123;  //对 八进制
    
    
    优先级
       
括号成员第一；    () [] . ->
全体单目第二；    ++ --  -  *  & 
乘除余三,加减四； * / %  + -
移位五，关系六；  << >>     > < >= <=
等于(与)不等排第七；== !=  
位与异或和位或；  &  ^   |  
"三分天下"八九十；!  && ||
逻辑或跟与；             
十二和十一； && ||
条件高于赋值,  ?:
逗号运算级最低！ ,
                    
    
正数的补码是原码
    00000111   7
    
    11111000   -8 
           1   先去掉补码
  -----------           
    11110111   
  ~
  ------------
    10001000   翻转  -8
       

    7
    00000111
    -7
    10000111 原码
    11111000 反码
    11111001 补码 
        
          
           
  if语句嵌套
    原则 条件后可以有一条语句，多条语句用{}括起来
    
    else总是和上面最近的if结合

    if(c==0)
  	if(a<b)
    if(b<0)  c=0;
    else  c+=1;
    else c++;
              
    if(c==0)
    {
    	if(a<b)
      {
    	   if(b<0)  c=0;
          else  c+=1;
      }
      else c++;
    }      
           
   全局变量和静态变量不赋初值默认为0
   局部变量和堆区，默认为乱码  
   
K=i*m+j
I=k/m;
J=k%m;
  
  
  当数组做形参时，是变量，用存地址 
  指针类型变量，用来存地址，所以数组名做形参本质就是指针变量
     
  int fun(char *a){//a是变量   
  //int fun(char a[3]){//a是变量
     printf("a=%p\n",a);
     a++;
     printf("a=%p\n",a);
  }
  int main(){
     char a[3]={1,2,3},b[]="China";
     //a++; 
     //a=b; //错 a是常量
     printf("b=%p\n",b);
     fun(b); //相当于 char a[3]=b;      
  }
        
    tmp=fun(n+k,d,(a,b));
    fun(a+b,(x,y),tmp);  
      
      
    a=0x1234
    a & 0x000f 
 
 
 
    
一、选择题 共40分
   1-5   B  B  A  D  B
   6-10  C  D  C  B  C
   11-15 C  D  C  A  A
   16-20 B  D  B  C  A

二、填空题 共20分
   1. 8,8,10
   2. 3FULL!4
   3. c+=5;
   4. 0
   5. j%3!=0
三、编程题
1.输入一个16位的数，可以看做每4位为一个数,共4个数，求这4个数的和。 5分
#include <stdio.h>
int main(int argc,char **argv){
    short a;
    scanf("%d",&a);
    //short b= (a & 0xF) + ((a>>4)&0xF)+((a>>8)&0xF)+((a>>12)&0xF);
    short b= (a & 0xF) + ((a/16)&0xF)+((a/32)&0xF)+((a/48)&0xF);
    
    printf("%d\n",b);
}
  

2.打印出所有的“水仙花数”，所谓“水仙花数”是指一个三位数，其各位数字立方和等于该数本身。例如：153是一个“水仙花数”，因为153=1的三次方＋5的三次方＋3的三次方。 8分    
#include <stdio.h>
int main(int argc,char **argv){
    int i;
    for(i=100;i<1000;i++){
        int g=i%10;
        int s=i/10%10;
        int b=i/100;
        if (g*g*g+s*s*s+b*b*b ==i) printf("%d ",i);
    }
}

3.幼儿园有大、小2个班的小朋友。分西瓜时，大班4个人一个，小班5个人一个，正好分掉10个西瓜；分苹果时，大班每人3个，小班每人2个，正好分掉110个苹果。编写程序，求幼儿园大班、小班各有多少个小朋友。 12分
  设 x 大
     y 小
     
     //x/4+y/5=10;
     
     5x+4y=200;
     3x+2y=110;

#include <stdio.h>
int main(int argc,char **argv){
    double x,y;
    for(x=1;x<40;x++){
       y=50-x*5/4;
       if (x*3 +y*2==110) {
          printf("--- x=%lf,y=%lf\n",x,y);
         break;
       }
    }
}
4.编写函数fun，函数的功能是：求5行5列矩阵的主、副对角线上元素之和。注意，两条对角线相交的元素只加一次。例如：主函数中给出的矩阵的两条对角线的和为45。要求矩阵以二维数组为参数的方式输传入。      15分
#include <stdio.h>
int add(int a[5][5]){
    int i=0,s=0;
    for(i=0;i<5;i++) s+=a[i][i];
    for(i=0;i<5;i++) s+=(i!=5-1-i)?a[i][5-1-i]:0;
    return s;
}
int main(int argc,char **argv){ 
    int a[5][5]={ 1, 2, 3, 4, 5,
                  5, 6, 7, 8, 9,
                 11,12,13,14,15,
                 16,17,18,19,20,
                 21,22,23,24,25};
    int sum=add(a);
    printf("---%d\n",sum);
}
//////////////////////////////////////////////////////
            指针
//////////////////////////////////////////////////////
一、内存地址
    地址：内存的编号，本质是无符号整型
    
    int a; //a是内存的名称 &a是地址
    
    *地址  是内存名
    &名称  是内存地址
    
    int a=12;
    &a  //地址值是随机分配
    *&a //就是a 是12 内存名就代表的内存中的值
    
    地址+num 地址在基址(开始地址)的基础上增加到
         num*sizeof(类型)
    
    假设
      char c='a'  &c的地址为12
      问 c+5之后的值是'f'
         &c+5   的值是17
      double d=2.3; &d的地址为12
         d+5    的值7.3
         &d+5   的值是 52
      
二、连续空间的内存地址                           
    int a[8]={9,2,3,4,5,6,7,8};
    a是内存空间的首地址
    *a 是 int的变量  4字节 是9 a[0]也是这个内存的名
       所以 a[0]就是 *a
    a+1 是a[1]的地址  
    *(a+1) 是内存名 是a[1]
    
    
    总结:
      a+i    就是&a[i]
      *(a+i) 就是a[i]
    
    问？下面的表达方式是否正确
      int b=12;
      &b[0] 错 b先和[0]结合
      (&b)[0] 对 就是b
      *(&b)   对 就是b
    
      int a=0x12345678;
      (&a)[0] 是0x12345678
           78  56  34  12
      ((char*)&a)[0] 是0x78
      
    问？下面是什么的地址
    int a[12];   元素是整型
    &a  是数组的地址，代表内存长度为48
    a   是a[0]的地址，代表内存长度为4
    a+1 是a[1]的地址  *(a+1) 就是a[1]
    
    int b[3][4]; 元素是数组
    &b  是面的地址
    b   是b[0]的地址 b[0]是数组名 代表内存长度16    
    b+1 是b[1]的地址  *(b+1) 就是b[1]
    接下来再研究里面的存的内存
        b[0][0] 就是 (b[0])[0] 就是 地址[0]
        
      
三、指针变量
    任何类型+*  为指针类型
    指针变量用于存内存的编号
1.栈区内存
    int main(){
      int a=12; //局部变量
      int* p=&a; //给p赋值，而不是给*p赋值
    }
    *p  就是变量名 值是12
    p[0]也是变量名 值是12
    
    p[1] 错 因为此时p开始的内存中只有一个4字节              
2.数据段内存
    int a=12; //全局变量
    int main(){
      int* p=&a; //给p赋值，而不是给*p赋值
      p[0]=23;
    }

3.堆区内存
    int main(){
      int* p=(int*)malloc(4);
      *p=23;
    }
    
    什么叫整型的指针类型，代表什么含义
    1)定义的变量存地址
    2)这个地址存的是整型的变量地址
    3)*地址 是整型的内存名
    4)地址 代表所控制的内存长度为4字节
    
    *和[]区别
    1)* 代表根据地址取值       *(p+1)第1个变量的值
    2)[] 代表根据地址偏移后取值 p[1] 从p偏移到第1个变量的值
    
4.连续内存
    int main(){
       int* p=(int *)malloc(4*12);  
       *p=12;  //p[0]=12;
       *(p+2)=23; //p[2]=23;
    }  
    
    int b[12];
    int main(){
       int a[12];
       int* p=a;
       *p=12;  //p[0]=12;
       *(p+2)=23; //p[2]=23;
       
       p=b;
       *p=12;  //p[0]=12;
       *(p+2)=23; //p[2]=23;
    }  
    
    
    练习：编写一个函数，用来申请一个内存，存储12个数据后，将地址返回给调用处
    在调用处打印这12个数
    
    分析：1)要求在函数中申请内存，然后添数
          所以数据段内存被排除
          2)如果我们在函数内用栈内存
          函数结束后，内存被释放，所以无法实现在调用处打印
          栈区内存被排除
          只能用堆区内存，堆区内存使用后要释放
    
     
    int* creatmem(int n){
        int i, *tmp=(int *)malloc(4*n);
        for(i=0;i<n;i++)  scanf("%d",tmp+i);
        return tmp;        
    }       
    int main(){
        int i;
        int *a=creatmem(12); //a存的是tmp的值        
        for(i=0;i<12;i++){
           printf("%d\n",a[i]);
        }  
        free(a); //根据地址释放内存  
    }
    
    
    
    
    练习: 编写一个函数，用来给一个已知字符串中的字符排序
    分析：已知字符串
          已经给定，对于函数来说需要传入，形参字符指针
          返回不需要
    
    void sort(char *buf){   //0x00000000 -0xffffffff
    //void sort(char buf[]){
        int i,j,len=strlen(buf);
        for(i=0;i<len-1;i++){//排第i个数      
           for(j=i+1;j<len;j++){//和第j个比
              if (buf[i]<buf[j]){
                 // char tmp=buf[i];
                 // buf[i]=buf[j];
                 // buf[j]=tmp;
                 buf[i]=buf[i]^buf[j];
                 buf[j]=buf[i]^buf[j];
                 buf[i]=buf[i]^buf[j];                 
              }
           }
        }
    }      
          
    int main(){
       char str[256]="ajdsk";
       sort(str);
       int i=0;
       //for(i=0;i<strlen(buf);i++) printf("%c",*(buf+i));
       printf("%s",str);
    }      
    
  
          
    int main(){
       char *str="ajdsk"; //错 buf[0]='a' 字符串只读
       sort(str);
       printf("%s",str);
    }        
   
    int main(){
    	 
       char *str=(char *)malloc(256); 
       strcpy(str,"ajdsk");
       sort(str);
       printf("%s",str);
    }       
四、常用函数
    /////////////////////////////////////////////////
    //1拷贝字符串
    char *strcpy(char *dest, const char *src)
    //2计算字符串长度  size_t是int
    size_t strlen(const char *s);
    //3比较两个字符串，如相等，返回0; s1>s2 返回正数; s1<s2 返回负数
    int strcmp(const char *s1,const char *s2);
     
    "abc"    "def"  因为 'a'<'d' 后面大
    "a"      "abc"  因为 '\0' <'b' 后面大
    "abc"    "abc"  相等

    练习: 用二维数组存多个字符串 排这个数组中的字符串排序        
    void sort(char ls[][4],int n){    	
        char tmp[4];
        for(i=0;i<n;i++){//排第i个数      
           for(j=i+1;j<n;j++){//和第j个比
              if (strcmp(ls[i],ls[j])>0){
                 strcpy(tmp,ls[i]);
                 strcpy(ls[i],ls[j]);
                 strcpy(ls[j],tmp);   
              }
           }
        }
    }                
    int main(){
      char ls[][4]={"abc","def","lll","fda"};
      sort(ls,4);
      int i;
      for(i=0;i<4;i++) printf("%s\n",ls[i]);     
    }        
    
    练习: 指针类型的数组存多个字符串 排这个数组中的字符串排序
    
    整型的数组:元素是整型变量
    字符的数组：元素是字符变量
    数组的数组：元素是数组
    指针的数组：元素是指针变量
    
    int  a[12];
    int* b[12];
    
    字符串 本身代表地址 “adsfsadf"
    char* ls[3]={"abd","fdadsf","aa"};
    ls[0]存的是"abd"的首地址
 
     void sort(char* ls[3],int n){    	
        char *tmp;
        for(i=0;i<n;i++){//排第i个数      
           for(j=i+1;j<n;j++){//和第j个比
              if (strcmp(ls[i],ls[j])>0){
                 //strcpy(ls[i],ls[j]); //错
                 tmp=ls[i];
                 ls[i]=ls[j];
                 ls[j]=tmp;
              }
           }
        }
    }                
    int main(){
      char* ls[3]={"abd","fdadsf","aa"};
      sort(ls,3);
      int i;
      for(i=0;i<3;i++) printf("%s\n",ls[i]);     
    } 
    
   //4将字符串src连接在dest后面
   char *strcat (char *dest,const char *src);
   
   例：
      int main(){
         //char str1[]="asdf"; //内存空间不足
         //char *str1="adfasd"; //内存为只读
         
         char str1[256]="asdf"; 
         char str2[]="dsfasdf";
         //或  char *str2="asfd";
         strcat(str1,str2);
         printf("%s\n",str1);
      }
   
   //5查找needle是否在haystack内，如果在，则返回needle在haystack内的起始地址，否则返回NULL
   char *strstr(const char *haystack,const char *needle); 
   
 
   练习：输入一个含绝对路径文件名，取出不包含路径的文件名
   
       char *getfile(char *path){
       /*  char *p=path;
           while((p=strstr(p,"/"))!=NULL) path=++p;
           reutrn path;
       */
       /*
           char *p=path;
           while(p!=NULL){
              path=++p;
              p=strstr(p,"/");
           }
           reutrn path;
       */
           int i=0;
           for(i=strlen(path)-1;i>=0;i--) {
              if (path[i]=='/') return path+i+1;
           }
           return NULL;
       }
       
       int main(int argc,char **argv){
           char *file=getfile(argv[1]);
           printf("%s\n",file);
       }

   //6查找字符c是否在s字符串内，如果在，则返回c在s内的地址，否则返回NULL
   char * strchr (const char *s,int c);
   
   char *pc=strchr("abcde",'b');
   或
   char *pc=strchr("abcde",66);
   *pc就是b
   
   //7从终端获取字符串
   char * gets(char *s);
   和scanf的区别 
     gets中间可以有空格 即空格是字符串中的一部分
     scanf输入的字符串，不包含空格
    
     char buf[256];
     gets(buf); 
     
   //8将字符串转换为双精度型
   double atof(const char *nptr);
   //9将字符串转换为整型
   int atoi(const char *nptr);
   例：
   int main(int argc,char **argv){
       int a=atoi(argv[1]);
       char *str="45";
       int b=atoi(str);
   } 
   
   //10按格式输出字符串到字符数组str内。可以用来将变量值转换为字符串
   int sprintf( char *str,const char * format,.........);
       可以实现整型转字符串、转各种进制字符串格式
       用于字符串之间的连接
   例：
   int main(){
      int a=23;
      double f=23.2;
      char buf[256];
      sprintf(buf,"%d",a);
      sprintf(buf,"%lf",f);
      sprintf(buf,"aaa:%s%s%d%x%o %d:%d","a","b",4,20,20,2,20);
   }    
   
   //11申请内存空间，参数为内存大小
   void * malloc(size_t size);
   //12释放申请的内存空间
   void free(void *ptr);             
   //13在原内存基础上扩展空间
   void *realloc(void *ptr,size_t size);  
   
   例：
   int main(){
      int n=4;
      char *p=(char *)malloc(n);//申请空间
      strcpy(p,"abc");
      p=(char *)realloc(p,n+12); //在原基础上扩展空间
      strcat(p,"defegetedafd");
      free(p);
   }
   
   问？数组元素个是否可变
   int a[2]; //2必须是常量
   
   //14将内存空间设置为c代表的整数
   void * memset (void *s ,int c, size_t n);
   
   int main(){
       char buf[256];
       memset(buf,0,256);//每个字节中都是填入0
       //前面填0后面填1
       memset(buf+0,0,128);
       memset(buf+128,1,128);
       //另一种清0
       bzero(buf,256);
   }

   //15拷贝内存
   void * memcpy (void * dest ,const void *src, size_t n); 
   memcpy和strcpy的区别
   memcpy拷贝任何的数据，包括多个0或'\0'
   strcpy拷贝'\0'和前面的字符
   int main(){
      char buf[256];
      strcpy(buf,"kasdf"); //拷5个字符及\0      
      memcpy(buf,"kasdf",6);
      //*** 
      int a=0x1234;
      double b=3.2;
      memcpy(buf,&a,4);
      memcpy(buf+4,&b,8);
      printf("--- %d,%lf\n",*((int*)buf),*((double*)(buf+4)));      
   }
   
  1.	已知数组int x[5]，输入5个数，编写程序，使用指针来计算数组元素总和及平均值
      int main(){
          int x[5]={1,2,3,4,5};
          int *p=x;
          int i,sum=0;
          //for(i=0;i<5;i++) sum+=p[i];
          //for(i=0;i<5;i++) sum+=*(p+i);
          //for(i=0;i<5;i++) sum+=*p++;
          for(i=0;i<5;i++,p++) sum+=*p;
          double agv=1.0*sum/5;
      } 
   2.	输入一串字符，统计它的字符总数，及大写字母和小写字母的个数，用指针实现（不可使用字符串函数）
      int main(int argc,char **argv){
          char *str=argv[1];
          int i=0,n1=0,n2=0;
          while(*(str+i)!='\0'){
             if (*(str+i) >='a' && *(str+i) <='z') n1++;
             if (*(str+i) >='A' && *(str+i) <='Z') n2++;
             i++;
          }
          printf("--- len=%d,大n=%d,小n=%d\n",i,n2,n1);
      } 
      
  3.	从键盘上输入两个字符串，判断第一个字符串中是否有第二个字符串，如果有，则给出第二个字符串在第一个字符串开始的地址，使用指针运算（不可以用strstr函数）。
      char *strstr1(char *str1,char *str2){
          int i=0,j=0;
          while(str1[i]!='\0'){//把str1的每个字符取出
              int sign=1; //标志，假设包含则为1
              if (str1[i]==str2[0]){ 
                 //如果str1中的第i个和str2的第0一样，就开始比较
                 while(str2[j]!='\0'){ //用str2[j]是否为0作条件
                    if (str2[j]!=str1[i+j] || str1[i+j]=='\0') {
                       sign=0; //标志，不包含
                       break;
                    }
                    j++;
                 }
              }
              else sign=0; //在str1中从没有发str2中的第0个一样的
              if (sign==1) return str1+i;
              i++;
          }
          return NULL;
      }
 
 4.	有3个学生各学4门课，计算每个学生的平均分，输出第n个学生成绩
         学生分数在数组初始化中赋值
         分别用如下方法计算并输出    
     一重循环，指针移动法
int main(){ //一维
    int sorce[3][4]={{23,56,87,90},{54,32,12,88},{45,56,78,89}};
    int i,sum=0;
    int *p=sorce[0];//p整型指针 存整型地址  sorce[0]数组名
    for(i=0;i<12;i++){
       sum+=*p++;
       if (i%4==3){
          printf("--- %lf\n",1.0*sum/4);
          sum=0;
       }
    }
}     
     一重循环，数组下标法
#include <stdio.h>
#include <string.h>
int main(){ //一维
    int sorce[3][4]={{23,56,87,90},{54,32,12,88},{45,56,78,89}};
    int i,sum=0;
    int *p=sorce[0];//p整型指针 存整型地址  sorce[0]数组名
    for(i=0;i<12;i++){
       sum+=p[i];
       if (i%4==3){
          printf("--- %lf\n",1.0*sum/4);
          sum=0;
       }
    }
}
 
int main(){ //二维
    int sorce[3][4]={{23,56,87,90},{54,32,12,88},{45,56,78,89}};
    int i,sum=0;
    for(i=0;i<12;i++){
       sum+=sorce[i/4][i%4];// i=k/m j=k%m
       if (i%4==3){
          printf("--- %lf\n",1.0*sum/4);
          sum=0;
       }
    }
}
    
     一重循环，数组偏移法
#include <stdio.h>
#include <string.h>
int main(){ //一维
    int sorce[3][4]={{23,56,87,90},{54,32,12,88},{45,56,78,89}};
    int i,sum=0;
    int *p=sorce[0];//p整型指针 存整型地址  sorce[0]数组名
    for(i=0;i<12;i++){
       sum+=*(p+i);
       if (i%4==3){
          printf("--- %lf\n",1.0*sum/4);
          sum=0;
       }
    }
}
 
int main(){ //二维 ****
    int sorce[3][4]={{23,56,87,90},{54,32,12,88},{45,56,78,89}};
    int i,sum=0;
    for(i=0;i<12;i++){
       //sum+=sorce[i/4][i%4];// i=k/m j=k%m
       //sum+=*(sorce[i/4]+i%4);
       //sum+=(*(sorce+i/4))[i%4];
        sum+=*(*(sorce+i/4)+i%4);
       if (i%4==3){
          printf("--- %lf\n",1.0*sum/4);
          sum=0;
       }
    }
}     
     
     两重循环，数组下标法
int main(){
    int sorce[3][4]={{23,56,87,90},{54,32,12,88},{45,56,78,89}};
    int i,j,sum=0;
    for(i=0;i<3;i++){
       for(j=0;j<4;j++){
          sum+=sorce[i][j];
       }
       printf("--- %lf\n",1.0*sum/4);
       sum=0;   
    }
}  
     两重循环，数组偏移法
int main(){
    int sorce[3][4]={{23,56,87,90},{54,32,12,88},{45,56,78,89}};
    int i,j,sum=0;
    for(i=0;i<3;i++){
       for(j=0;j<4;j++){
          sum+=*(*(sorce+i)+j);
       }
       printf("--- %lf\n",1.0*sum/4);
       sum=0;   
    }
}       

    二维数名是首行地址，用什么来存行地址？
    行指针变量,行是一个一维数组，即数组指针变量
    定义方法
       int (*p)[4]; //p是一个行指针变量
       存一个4个元素的一维数组的地址
        
    1)存一维数组的地址
      int a[4]={4,5,6,7};
      &a;//代表16字节空间  &a+1 第16字节的地址
      a  //代表4字节空间   a+1  第4字节的地址
      int (*p)[4]=&a;
      此时p就是&a
      p+1 第16字节的地址
      *(p+1)第16字节位的名(地址) 即第2行的名
      p[0][j]是第0行第j列的值
    2)存二维的行地址
      int b[3][4];
      b[0] 元素
      b[1] 元素
      b[2] 元素
      b是数组名,也是b[0]的地址
      分析b[0]是一维数组名 所b就是数组的地址,所以称为首行地址
      
      int (*p)[4]=b; //存数组的地址
      此时p就是b  b是常量  p是变量
      p+1  第1行地址
      p+2  第2行地址
      p[0] 第0行名  b[0] 
      
         
        
     两重循环，指针下标法（数组的指针）
int main(){
    int sorce[3][4]={{23,56,87,90},{54,32,12,88},{45,56,78,89}};
    int i,j,sum=0;
    int (*p)[4]=sorce;
    for(i=0;i<3;i++){
       for(j=0;j<4;j++){
          sum+=p[i][j];
       }
       printf("--- %lf\n",1.0*sum/4);
       sum=0;   
    }
}      
     两重循环，指针偏移法（数组的指什）
int main(){
    int sorce[3][4]={{23,56,87,90},{54,32,12,88},{45,56,78,89}};
    int i,j,sum=0;
    int (*p)[4]=sorce;
    for(i=0;i<3;i++){
       for(j=0;j<4;j++){
          sum+=*(*(p+i)+j);
       }
       printf("--- %lf\n",1.0*sum/4);
       sum=0;   
    }
} 

   
    typedef int INT;
    typedef int* PINT;
    typedef int (*PFUN)(int,int); //PFUN是函数指针类型
    typedef int (*PARRAY)[4];
    typedef int (*PEW)[4][8];
    INT是int的别名  所以也是类型
    int max(int x,int y){
        return x>y?x:y;
    }
    int main(){
        INT a=12;
        PINT p=&a;
        PFUN p1=max;
                
        int a[4];
        PARRAY p2=&a;
        int b[3][4];
        p2=b;
    }
    
    作业：实现下面的函数
    char *strcpy1(char *dest,const char *src){
        int i=0;
        while(1){
           dest[i]=src[i];
           if (src[i]=='\0') break;
           i++;
        }
        return dest;
    }
    
    size_t strlen1 (const char *s){
        int i=0;
        while(s[i++]!='\0') ;
        return i;
    }
    
    int strcmp1(const char *s1,const char *s2){
        int i,diff=0;
        while(diff==0){
           diff=s1[i]-s2[i];
           if (diff==0 && s1[i]=='\0') return 0;
           else if (diff!=0) return diff; 
           i++;
        }
    }
    
    char *strcat1 (char *dest,const char *src){
        int i,len;
        for(len=0;dest[len]!='\0';len++);   
        while(1){
           dest[len+i]=src[i];
           if (src[i]=='\0') break;
           i++;
        }
        return dest;        
    }
    char *strstr(const char *haystack,const char *needle); 
   
    编写一个函数，传入字符型二维数组，形参是指针变量，实现字符串的排序
    //void sort(char ls[][256],int n){
    void sort(char (*ls)[256],int n){
              
    }
    
    
    编写一个函数，申请一个内存，用来存二维数据，并返回二维数组
    #define COLS  4
    typedef int (*PARRAY)[COLS];
    PARRAY creatarray(int row){
        int i,j;
        PARRAY p=(PARRAY)malloc(row*COLS*4);
        //for(i=0;i<row*COLS;i++) scanf("%d",p[0]+i);
        //或
        for(i=0;i<row;i++){
           for(j=0;j<COLS;j++) scanf("%d",p[i]+j);
        }
        return p;   
    }
    
    int main(){
        
    }
     
////////////////////////////////////////////////////
五、指针数组和指针的指针
    指针：是存地址的变量
    int  a;     //存整型
    int  *p=&a; //p存整型的地址
    
    int  a[];   //一维数组 存整型
    int  *p=a;  //p存整型的地址
         
    int* a;     //存地址
    int* *p=&a; //p存指针的地址
    
    int* a[];   //一维数组 存地址
    int* *p=a;  //p存指针的地址
    
    例：
    int a=12,b=23;
    int* p=&a;
    int** pp=&p;
    
    *pp是变量p
    *(*pp) 是*p  是a   可写成**pp
    
    p=&b;
    **pp  *pp是p 存b的地址，所以*pp就是b的地址 **pp就是b
    
    例：
    int a=12,b=34,c=22,d=45;
    int* s[]={&a,&b,&c,&d};
    int* *p=s;
    p是 s[0]的地址 s[0]是a的地址  
    *p是a的地址
    **p 是a
    
    
    例：
    char* ls[3]={"asdf","dsf","gasd"};
    char** p=ls;
    ls[0] 是"asdf"首地址
    p[0]  是"asdf"首地址
    *p    是"asdf"首地址
    **p   是'a' 
  
     
  指针和数组的关系 
    (整型的)数组:元素是(整型)变量 
                (整型)指针就是(整型)数组名           
    (浮点的)数组:元素是(浮点)变量 
                (浮点)指针就是(浮点)数组名     
    (字符的)数组:元素是(字符)变量 
                (字符)指针就是(字符)数组名
    (结构的)数组:元素是(结构)变量 
                (结构)指针就是(结构)数组名
    (数组的)数组:元素是(数组) 
                (数组)指针就是(数组)数组名
    (指针的)数组:元素是(指针) 
                (指针)指针就是(指针)数组名
    (函数指针的)数组:元素是(函数指针) 
                (函数指针)指针就是(函数指针)数组名
    .....
    总结
    (任何类型的)数组:元素是(任何类型) 
                (任何类型)指针就是(任何类型)数组名

   区别下面代表的函义

#1)  int p;
     (整型)变量 :代表变量中存整型
     例：int p=12;
     
#2)  int *p;
#4)  int p[4];    //4个变量 存整型
     (指针)变量 :代表变量中存整型地址
     例：int a=12;
         int *p=&a;
     *地址 是变量名
     &变量 是地址
     *p 就是a
     
     例：int a[4]={1,2,3,4};
         int *p=a;
     p 就是 a
     *p 就是 a[0] == *a 
     *(p+i) 就是 a[i] == *(a+i)  
     
#3)  int **pp;
#5)  int *p[4];   //4个变量 存(整型)地址
     ((指针的)指针)变量 :代表变量中存整型指针的地址
     例：int a=12;
         int *p=&a;
         int **pp=&p;
      *pp是 p
      **pp就是 *p 就是 a   

     例：int c,d,e,f;
         int *a[4]={&c,&d,&e,&f};
         int **p=a;
         p 就是a
         *p 就是a[0] == *a
         *(p+i)就是 a[i] == *(a+i)
         
         a[0]是c的地址 *a[0]就是c == a[0][0] == **p == **a 
         (不是二维数组)
         
         d如何找 a[0]+1; //错 c和d内存空间不连续
                 *a[1]; == a[1][0] == **(a+1)==**(p+1)//对
                  
         地址[i] == *(地址 +i)
     
     例:  
         char c='a';
         char e[]="sdf";
         char *f="afd";
         char* a[4]={&c,"asdf",e,f};
         char* *p=a;
         
         p[0][0]==  c
         p[3][2]==  f内的'd' ==  *(p[3]+2) == *(*(p+3)+2)
         p不是二维数组名
     
#6)  int (*p)[4]; //1个变量 存(是4个元素的数组的)地址
     (数组的)指针 
     
     例：int a[4]={1,2,3,4};
         int (*p)[4]=&a;  //数据类型是int (*)[4]
          
         p+1  //p 代表16字节
         p 是行地址  == &a
         p[0] 是行的名 即数组名  == a
         p[0]+1 是 a+1 是a[1]的地址 
         *(p[0]+1) == 2 == *(*(p+0)+1) == p[0][1]
         p是二维数组名 
         
     例：int a[3][4]={1,2,3,4,5,6,7,8,9,10,11,12};
         int (*p)[4]=a;
         
         p+1  是第1行地址 是 a[1]地址
         *(p+1)是第1行名  是 a[1] 是5所在元素的地址
         *(p[i]+j) ==  *(*(p+i)+j)==(*(p+i))[j] == p[i][j]
     
 
#7)  int*(*p)[4]; //1个变量 存((元素是指针类型)数组的)地址
     ((元素是指针)数组的)指针
     
     例 char* s[3][3]={{"张三","男","学生"},
                       {"李四","女","家长"},
                       {"王五","男","家长"}};
        char* (*p)[3]=s; //s是首行地址
                              
        p[1][2]是“家长"字符串地址
        printf("%s\n",p[1][2]);
        *p[1][2] 是半个"家"
        
        *(*(p+1)+1) 是"女"字符串地址
        **(*(p+1)+1) 是半个"女"
        
        ***p 是个半"张"  == *p[0][0]        

 8)  int (*p[4])[4]; //4个变量 存(是4个元素的数组的)地址
    

     int  p(); //函数的声明 返回类型为int
     int* p(); //函数的声明 返回类型为int*
    
#9)  int (*p)();  //1个变量 存(函数的)地址
     p是指针变量 存函数地址，函数格式:返回类型为int 无参数
     
     例：
     int fun(){
        int a=random(); //产生一个随机数
        return a;
     }
     int main(){
        int (*p)()=fun; //p是指针，存函数地址，p就是函数
        printf("--- %d\n",p());//函数名就是地址 p就是函数
        printf("--- %d\n",(*p)());//p是地址，*p就是名
        printf("--- %d\n",*p());  //错 给返回值加*
        printf("--- %d\n",*p);  //错 打印是函数地址
        printf("--- %d\n", p);  //错 打印是函数地址
     }

#13) int *(*p)(); //1个变量 存(指针函数)地址
     p是指针变量 存函数地址 函数格式:返回类型是int*
    
    例 返回整型地址 
     int* fun(){
        int* a=(int*)malloc(4);
        *a=random(); //产生一个随机数
        return a; //返回地址
     }
     int main(){
        int* (*p)()=fun; //p是指针，存函数地址，p就是函数
        printf("--- %d\n",p()); //错 打印a内的地址
        printf("--- %d\n",*p());//对 返回值是地址*p()是*a
     }
     
    例 返回数组
     int* fun(){
        int i,* a=(int*)malloc(4*12);
        for(i=0;i<12;i++) a[i]=random(); //产生一个随机数
        return a; //返回地址
     }
     int main(){
        int* (*p)()=fun; //p是指针，存函数地址，p就是函数
        printf("--- %d\n",p()); //错 打印a内的地址
        printf("--- %d\n",*p());//对 返回值是地址*p()是*a
        printf("--- %d\n",*(p()+2));//对
     }     
     
     
#14) int**(*p)(); //1个变量 存(指针函数)地址
     p是指针变量 存函数地址 函数格式:返回类型是int**
     
     例：返回指针数组
      int b=12,c=23,d=34,e=45;
      int** fun(){
        int i,**a=(int**)malloc(4*4);
        a[0]=&b;
        a[1]=&c;
        a[2]=&d;
        a[3]=&e;
        return a; //返回地址
     }
     int main(){
        int** (*p)()=fun; //p是指针，存函数地址，p就是函数
        int i;
        int** tmp=p();
        for(i=0;i<4;i++){
           printf("%d\n",*tmp[i]);
        }
     }     
     
 
 10) int (*p[4])(); //4个变量 存(函数的)地址
 11) int (**p)(); //1个变量 存(函数指针的)地址
     p是数组名 存函数地址
     
    int max(int x,int y){
        return x>y?x:y;
    }           
    int add(int x,int y){
        return x+y;
    }           
    int sub(int x,int y){
        return x-y;
    }           
    int mul(int x,int y){
        return x*y;
    }           
    int div(int x,int y){
        return x/y;
    }  
    typedef int (*PFUN)(int x,int y);
    int main(){
        //一个函数指针变量
        int (*p)(int x,int y)=max; //一个变量，存函数地址
        int a=p(12,23);
        //多个函数指针变量
        int (*p1[])(int x,int y)={max,add,sub,mul,div};
        int (**pp)(int x,int y)=p1; //一个变量
        int i;
        //for(i=0;i<5;i++) printf("--%d\n",p1[i](12,23));
        for(i=0;i<5;i++) printf("--%d\n",pp[i](12,23));
        
        PFUN p2[]={max,add,sub,mul,div};
        PFUN* pp2=p2;
        for(i=0;i<5;i++) printf("--%d\n",pp2[i](12,23));
    }  

 15) int *(*p[4])(); //4个变量 存(指针函数)地址
    
    整型变量 存整型
    整型指针 存地址
    数组指针 变量，存数组行地址
    指针数组 数组，存多个地址
    函数指针 变量，存函数地址
    指针函数 函数，返回指针
    
    
六、函数和指针
(一).函数的参数
      哪些类型可以做函数参数?
      所有类型
      基本类型:int long short char double float
      自定义类型：数组、枚举、联合体、结构体、类、typedef
      指针类型: void* 其它类型*  (即各种类型的地址)
      引用类型: 其它类型& (即各种类型的别名)
    
      如何确定在编程时使用哪个类型？
 1.基本类型，用于向函数中传递一个数据
      int max(int x,int y){
          return x>y?x:y;
      }
      int main(){
          max(12,23); //12赋给了x 就是将12传入了函数中
      }
      
 2.指针类型
      1).有大量的数据要传入函数，用这些数据的首地址传入
      int fun(int *a){
          int i,s=0;
          for(i=0;i<12;i++,a++) s+=*a;
          return s;
      }; 
      int main(){
          int a[12]={1,2,3,4,5,6,7,8,9,10,11,12};
          fun(a);
      }
      
      2).如果需要函数返回多个值，但函数只能返回一个，其它数可以通过形参传入内存地址，在函数中填写该内存中的值 
      int* fun(int *n){ //n是指针
         int *p=malloc(12*4);
         *n=12;    //根据地址改写内存中的值
         return p;
      }; 
      int main(){
         int n;
         int *p=fun(&n); //传入n的地址
         printf("---p=%x, n=%d\n",p,n); //打印 地址和 12
      }
      
 3.引用类型 只能用于c++
      int* fun(int& n){ //n是别名
         int *p=malloc(12*4);
         n=12;    //根据地址改写内存中的值
         return p;
      }; 
      int main(){
         int n;
         int *p=fun(n); //传入n的地址
         printf("---p=%x, n=%d\n",p,n); //打印 地址和 12
      }


(二).函数的返回类型
     如何确定函数的返回类型?
     根函数计算的结果确定返回类型。
     计算的结果是(..)的地址，返回类型是(...)指针类型
     计算的结果是(..)的数组, 返回类型是(...)指针类型
     
     int max(int x,int y){ }
     int add(int x,int y){ }
     int div(int x,int y){ }
     int sub(int x,int y){ }     
     int fun( int (*p)(int,int) ){
         return p(12,23);
     }     
     int main(){
         int a=fun(max);
         printf("--%d\n",a);
     }
     
    有两种类型，必须用typedef 来重定义才能做返回类型
    typedef int (*PFUN)(int,int); //PFUN是新类型
    typedef int (*PARR)[4];       //PARR是新类型
    typedef int (*PARR1)[4][8];   //PARR1是新类型
  例：  
    PFUN fun(int i){
       PFUN p;
       switch(i){
       case 0:p=max; break;
       case 1:p=add; break;
       case 2:p=sub; break;
       case 3:p=div; break;
       }
       return p;
    }
    int main(){
       int d=fun(1)(12,23);
       printf("--- %d\n",d);
    }
    
   例：
   PARR fun(int n){
      PARR p=(PARR)malloc(n*4*4);
      return p;
   } 
   int main(){
       PARR p=fun(2); //p是二维数组名       
   } 
   例：
   int** fun(int n){
      int** p=(int **)malloc(n*4);
      return p;
   } 
   int main(){
      int** p=fun(2); //p指针类型数组名 2个元素       
   }    
   
   
(三).函数指针用途 ****
   1.做回调
   2.通过结构体做接口
   3.linux系统api，用来实现代码并行运行(线程)
     让一个函数由CPU独立运行
     设置一个函数由CPU独立运行的系统调用
     pthread_create(pthread_t *id,NULL,函数地址,NULL);
     参数 id 线程id 代表由pthread_create生成的编号
          函数地址要求的格式 void *函数名(void *参数)
     
 例：播放流程控制
    //mplay.h
    #ifndef MPLAY_H
    #define MPLAY_H
    /* 函数功能：播放音频
       返回值：0 成功  -1 失败
       参  数: file 文件名
               handler 函数指针 
       handler结构 参数int,int 分别代表state 和vaule
    */
    extern int play(char *file,int (*handler)(int,int));
    /*函数功能:暂停
      返回值：0 成功 -1失败
    */
    extern int pause();
    
    /*函数功能:停止
      返回值：0 成功 -1失败
    */
    extern int stop();
    
    #endif
              
               
    //mplay.c
    #include <stdio.h>
    #include <stdlib.h>
    #include <string.h>
    static int (*sendstate)(int,int);
    static int state;  //0 停止  1播放  2暂停
    
    void* run(void* arg){
        int i=0;
        int size=180;
        while(state){
           while(state==2) usleep(20000);//微秒
           //1) 读取磁盘文件
           //2) 解码
           //3) 写入声卡
           //4) 调用回调，将数据传入到UI层
           sendstate(state,i++);
           if (i>=size) break;
           sleep(1);
        }
        state=0;
        sendstate(state,i++);
    
    }
    
    
    int play(char *file,int (*handler)(int,int)){
        if (state==0){
           //1.保存函数地址到全局
           sendstate=handler;
           state=1;
           //2.启动一个循环
           pthread_t id;
           pthread_create(&id,NULL,run,NULL);
        }
        else state=1;
    }
    
    int pause(){
        state=2;
        sendstate(state,0);
    }
    
    int stop(){
        state=0;
        sendstate(state,0);
    }
    
    
    //test.c
    #include <stdio.h>
    int curstate;
    int getstate(int state,int val){
        curstate=state;
        printf("---- state =%d,val=%d\n",state,val);
    
    }
    
    int main(int argc,char **argv){
        char cmd[256];
        while(1){
           scanf("%s",cmd);
           if (strcmp(cmd,"q")==0) break;
           else if (strcmp(cmd,"p")==0){
                if (curstate==2)
                   play(NULL,NULL);
                else {
                   printf("请输入文件名:\n");
                   scanf("%s",cmd);
                   play(cmd,getstate); //播放
                }
           }
           else if (strcmp(cmd,"s")==0)
                stop();
           else if (strcmp(cmd,"z")==0)
                pause();
        }  
   }
    
   作业：1)笔记理解
         2)音频播放流程的编写
         3)标准C语言_08_01.doc
           标准C语言_09_01.doc
//////////////////////////////////////////////////////

预处理指令 1
   预处理指令 不是C语言 是编译器指令
   三种指令
   1.宏定义
   2.include
   3.条件编译
   
   本质都在编译初期进行替换
1.宏定义


   #define 宏名 [数据]
   后面没有分号

 1)宏的基本用法    
   (1)在多处使用3.14时，如果使用宏，方便改动
   
   #define PI 3.14
   int main(){
       int r=2;
       double s=r*r*PI; //本质，在编译时，将PI替换为3.14
   }   
   
   (2)将数字用来代表具体函义的值，此时使用宏
   
   #define SUN 0
   #define MON 1
   int main(){
     int a;
     scanf("%d",&a);
     switch(a){
     case SUN: printf("周日") break;
     case MON: printf("周一") break;
     ...
     }
   }     
   
   (3)用数字代表某个具体指令,此时使用宏 (高编)
   (4)用代表寄存器某个位的值  (驱动)
   
 2)带参数的宏
   #define 宏(参数列表) 表达式
   
   #define MUL(x,y) x*y
   int main(){
       int a=MUL(12,2);  //24 
       int b=MUL(12+1,2);//14 展开后 b=12+1*2  
   }   
   注意事项：写这类的宏，一定要在后面表达式的参数上加（）
   #define 宏(参数列表) 表达式
   
   #define MUL(x,y) (x)*(y)
   int main(){
       int a=MUL(12,2);  //24 
       int b=MUL(12+1,2);//26 展开后 b=(12+1)*(2)  
   }  
   
   练习：编写一个宏，用来计算两个数的最大值
         编写一个宏，用来打印字符串
         #include <stdio.h>
         #define max(x,y) (x)>(y)?(x):(y)
         #define print(x) printf("%s\n",(x))
         int main(){
            int a=max(12,23);
            printf("%d\n",a);
            print("asfdsfdasdf");
         }   
                  
         编写一个宏，用来实现将两个字节型数据组合成一个短整型
         #define SOFC(x,y) ((x)<<8) | (y)
         int main(){
            short a;
            char a1=0x12;
            char a2=0x34;
            a=SOFC(a1,a2);
            printf("%x\n",a);
         }
         或         
         #define SOFC(z,x,y) { \
            char *p=(char*)z; \
            p[0]=(y); \
            p[1]=(x); \
         }
         int main(){
            short a;
            char a1=0x12;
            char a2=0x34;
            SOFC(&a,a1,a2);
            printf("%x\n",a);
         }

    
    
2.#include
    本质，是替换 
    <>  /usr/include
    ""  当前目录下
    
3.条件编译
    根据条件进行编译
  1) #ifndef .... #endif
     判断是否定义了宏，如果没定义则编译  
    
     通常用于头文件中 
     
  2) #ifdef .... #endif
     判断是否定义了宏，如果定义了则编译
     
     通常用于系统移植   
     #define LINUX
     int main(){
         double s=12;
     #ifdef WIN
         int r=2;
         s=r*r*3.14;
     #endif
         printf("%lf\n",s);
     }     
   
  3) #if 值
       代码
     #elif
       代码
     ....
     #else
       代码
     #endif
     
     根据条件决定编译哪些语句
     
     (1)通常用于调试程序 #if 0 就相当于多行注释

     #define LINUX
     int main(){
         double s=12;
     #if 0
         int r=2;
         s=r*r*3.14;
     #endif
         printf("%lf\n",s);
     }      
     
     (2)根据配置来决定编译的内容
     #define V 2
     int main(){
         double s=12;
     #if V==1
         int r=2;
         s=r*r*3.14;
     #elif V==2
         int r=3;
         s=4*3;
     #elif V==3
         int r=9;
         s=3;
     #endif
         printf("%lf\n",s);
     }
     
             
#undef 取消宏的定义
       
    
//////////////////////////////////////////////////////
文件操作
   //打开文件
   FILE *fopen(const char *path, const char *mode);
   返回类型 FILE*  文件类型的指针类型(句柄) FILE是结构体  
   参数 path 含路径的文件名 
        mode 打开方式
             “r”   只读  
             “w”   只写  
             “a”   追加  
    
   //关闭文件
   int fclose(FILE *fp); 
   参数：fp 指明关闭哪一个打开的文件
   //将文件指针(光标)移到文件头
   void rewind(FILE *stream);
   //将文件指针按(光标)指定的方式移动
   int fseek(FILE *stream, long offset, int whence); 
   参数：stream 是FILE *类型，用于指明操作的是哪一个打开的文件
         offset  指明移动的长度,字节。
         whence  指明从哪里开始移动
                  SEEK_SET  0   文件头向后移
                  SEEK_CUR  1   当前位置向后移
                  SEEK_END  2   从文件尾向后移。
   //读取指针(光标)位置
   long ftell(FILE *stream);
   参数：stream 是FILE *类型 。
   返回值：当前指针在文件中的位置，单位是字节。
   
   //数据块读写函数
   size_t fread(void *ptr, size_t size, size_t nmemb, FILE *stream);
   size_t fwrite(const void *ptr,  size_t  size, size_t nmemb, FILE *stream);
   参数：ptr 内存地址。
   对于fread来说，是准备好的空内存地址。对于fwrite来说，是要写入磁盘的数据。
       size 内存块大小
       nmemb 内存块数量   读写数据的总长度是 len=size *nmemb;  通常设为1
       stream 即FILE指针，是open返回值，用于指明操作的是哪一个打开的文件。
   返回值：实际读取或写入的内存块个数   失败返回-1          
                  
   例：
        #include <stdlib.h>
        #include <string.h>
        int main(int argc,char **argv){
            char buf[256];
            FILE *fp=fopen(argv[1],"r");
            if (fp==NULL){
                fp=fopen(argv[1],"w"); //文件不存在，则自动创建
                scanf("%s",buf);
                //将数据写入到磁盘
                int size=fwrite(buf,strlen(buf),1,fp);
                printf("---- size =%d\n",size);
            }
            else {
                fseek(fp,0,2); //将光标移到文件尾
                int size=ftell(fp); //读取光标位置 即文件大小
                rewind(fp); //将光标移到文件头，等待读数据
                size=fread(buf,size,1,fp);
                printf("---- size=%d,buf=%s\n",size,buf);
            }
            fclose(fp);
        }
                       


 
    
    
    
    作业：     
         
         编写一个宏，用来实现将一个整型写入拆分成4个字节数据
         #define ITOC(z,x1,x2,x3,x4) {\
               char *p=(char*)&z; \
               x1=p[0]; \
               x2=p[1]; \
               x3=p[2]; \
               x4=p[3] \
               }
         
         #define ITOC(z,x1,x2,x3,x4) { \
               x1=z & 0xff; \
               x2=(z >>8) & 0xff; \
               x3=(z >>16) & 0xff; \
               x4=(z >>24) & 0xff; \
               }
         int main(){
             int a=0x12345678;
             char a1,a2,a3,a4;
             TTOC(a,a1,a2,a3,a4);         
         }
         

         
         编写一个宏，用来实现将一个双精度数据拆分成8个字节
         #define FTOC(z,x1,x2,x3,x4,x5,x6,x7,x8) {\
               char *p=(char*)&z; \
               x1=p[0]; \
               x2=p[1]; \
               x3=p[2]; \
               x4=p[3] \
               ...
               }
         
         编写一个宏，用来实现将8个字节数据合成一个双精度值
         #define FTOC(z,x1,x2,x3,x4,x5,x6,x7,x8) {\
               char *p=(char*)&z; \
               p[0]=x1; \
               ....
               }
         
         
   
         编写一个程序，用于将整型数组，保存到磁盘中，当再次打开时，打印磁盘中的数组数据。
         
        #include <stdio.h>
        #include <stdlib.h>
        #include <string.h>
        int main(int argc,char **argv){
            FILE *fp=fopen(argv[1],"r");
            if (fp==NULL){
                fp=fopen(argv[1],"w"); //文件不存在，则自动创建
                int n;
                printf("input n:\n");
                scanf("%d",&n);
                int i,*p=(int*)malloc(n*4);
                printf("input num:\n");
                for(i=0;i<n;i++) scanf("%d",p+i);
                //将数据写入到磁盘
                //1.        
                //int size=fwrite(p,n*4,1,fp);
                //2.
                for(i=0;i<n;i++) fwrite(&p[i],4,1,fp);
            }
            else {
                fseek(fp,0,2); //将光标移到文件尾
                int size=ftell(fp); //读取光标位置 即文件大小
                rewind(fp); //将光标移到文件头，等待读数据
                int i,n=size/4;
                int *buf=(int*)malloc(n*4);        
                size=fread(buf,n*4,1,fp);
                for(i=0;i<n;i++) printf("%d ",buf[i]);
                free(buf);
            }
            fclose(fp);
        
        
        }
         
         
         
         编写一个程序，打开已有的文件，该文件中保存的是一个字符串，打开后，将该字符串排序后重新保存到该文件中
         
        int main(int argc,char **argv){
            //读取
            FILE *fp=fopen(argv[1],"r");
            if (fp==NULL) return 0;
            fseek(fp,0,2);
            int size=ftell(fp);
            fseek(fp,0,0);
            char buf[256];
            fread(buf,size,1,fp);
            fclose(fp);
            //排序
            int i,j,n;
            for(n=0;buf[n]!='\0' && buf[n]!='\n' && buf[n]!='\r';n++);
            for(i=0;i<n;i++){
                for(j=i+1;j<n;j++){
                   if (buf[i]>buf[j]){
                       char tmp=buf[i];
                       buf[i]=buf[j];
                       buf[j]=tmp;
                   }
                }
            }
            //保存
            fp=fopen(argv[1],"w"); //文件不存在，则自动创建
            if (fp==NULL) return 0;
            fwrite(buf,n,1,fp);
            fclose(fp);
        
        }
         
         
     编写一个程序，打开已有的文件，该文件中保存了多行数据，实现在文件中查找指定的字符串
     int main(int argc,char **argv){
         
         FILE *fp=fopen(argv[1],"r");
         if (fp==NULL) return 0;
         //判断文件长度
         fseek(fp,0,2);
         int size=ftell(fp);
         fseek(fp,0,0);
         //申请内存 并读取数据到内存
         char *buf=(char*)malloc(size);
         fread(buf,size,1,fp);
         fclose(fp);
         //在内存中查找字符串
         int row=1;
         char *p, *p1=buf,*p2;  //指定p1 和p2分别为一行的开始和结束的地址
         while(p1!=NULL){
            p2=strstr(p1,"\n"); //找\n所在的位置当做p2的位置
            if (p2!=NULL) {
                *p2=0;    //将内存中的\n改为\0  做为字符串的结束  
                p2++;     //p2此时指向下一行的开始
            }
            p=strstr(p1,argv[2]); //找字符串
            if (p!=NULL && p <p2){ //找到了并在p2前，则打印
                printf("%-3d:%-3d %s\n",row,p-p1+1,p1);
            }
            //-------------------
            p1=p2;
            row++;
         }
         free(buf);
     }         
         


///////////////////////////////////////////////////////////////////////////////////////

自定义数据类型 
  1) typedef 
     typedef int* PINT;  PINT是指针类型  是int*别名
     typedef PINT* PPINT; 
     
     数组指针类型
     typedef int (*PARR)[4]; PARR是数组指针类型
     函数指针类型
     typedef int (*PFUN)(int,int);  PFUN是函数指针类型
     
  
     任何一个typedef定义的新类型必须依据已存在的类型来定义
        
  2) 枚举类型
     是一一列举数据
     enum  枚举类型名 {枚举元素列表} 枚举变量列表；
     
     例
     enum COM {com1,com2,com3,com4,com5};
     
     int main(int argc,char **argv){
         enum COM a=com1; //enum COM是类型   
         //com1是 0 com2是 1 本质上枚举元素都是常量
         a=1; //说明a内可以存整型 也更说明了枚举类型就是整型
     }
     
     常量的几种写法 
     #define d 4;    //d是常量 称为宏常量  编译时替换
     const int c=3;  //c是常量 称为只读变量 只能被使用 3给c赋值只能赋初值  
     enum COM {com1=2,com2=5,com3=7,com4,com5}; //com1是常量 称为枚举常量 可以指定值，没有指定的值按前面依次排列
     enum WWW {aaa=2,bbb=5,ccc,ddd,eee} c1,c2; //c1和c2是变量名
     int main(int argc,char **argv){
         c1=aaa;
         c2=ccc;
         printf("--- %d\n",c);    
         printf("--- %d\n",com1);
         printf("--- %d\n",com2);
         printf("--- %d\n",com3);
         printf("--- %d\n",com4);
         printf("--- %d\n",com5);
     
     }        

     typedef enum WEEK{sun,mon} week_t; //定义类型的同时定义别名 week_t是类型名
     typedef enum WEEK * pweek_t;  //已义完的类型定义别名
     int main(int argc,char **argv){
          week_t  w=mon;
          switch(w){
          case sun:
              printf("---- %d\n",w); break;
          case mon:   
              printf("---- %d\n",w); break;     
          }
     } 

  3 联合体类型 即共用体
     union 类型名{ 
       数据类型 成员名;
       .... 
     };
     在联合体类型中，每个成员共用了同一块内存空间 联合体类型的长度，是最大的成员长度
     
     联合体类型变量.成员名
     联合体类型指针->成员名
     其中.和-> 成员运算符，是用来读取成员变量的
     
     例：
     union Ip{
        int ip;  //整型ip
        char ipstr[4]; //字节型ip
        char note[80]; //注释
     };

     int main(){
        union Ip ip; //union Ip是类型 ip是变量名
        ip.ipstr[0]=192;
        ip.ipstr[1]=168;
        ip.ipstr[2]=1;
        ip.ipstr[3]=8;
        printf("----- %d\n",ip.ip);
        int i;
        for(i=0;i<80;i++) printf("%u ",(unsigned char)ip.note[i]);
        printf("\n");
        int d=8 <<24 | 1 <<16 | 168 << 8 | 192;
        printf("----- %d\n",d);

     }

  
   
  4 结构体类型
    结构体:不同类型数据的集合，内存空间连续
    数组： 相同类型数据的集合，内存空间连续
   
  1)结构体的定义  
    struct 类型名{
      类型 成员名;
      ....    
    };
    例：
    
    struct Student{
       int id;
       char name[40];
       char sex[4];
       int age;
    };

    int main(){
       struct Student s1;
       s1.id=1;
       strcpy(s1.name,"zhangsan");
       strcpy(s1.sex,"man");
       s1.age=23;
       printf("%d,%s,%s,%d\n",s1.id,s1.name,s1.sex,s1.age);
    
    }  
    
 2)结构体成员的初始化
    int main(){
       struct Student s1={2,"lisi","wom",34};
       printf("%d,%s,%s,%d\n",s1.id,s1.name,s1.sex,s1.age);
       
       
       struct Student s[5]={{2,"lisi","wom",34},
                            {3,"lisi","wom",34},
                            {4,"lisi","wom",34}};
    
    }  
    ~        
 3)结构体指针
   int main(){
      struct Student s1={2,"lisi","wom",34};
      struct Student* p=&s1;
      printf("%d,%s,%s,%d\n",p[0].id,p->name,(*p).sex,p->age);
   }  
     
  练习：编写一个程序，将5个学生的信息保存到文件中，当再次执行该程序，则打印已保存的学生信息
   int main(int argc,char **argv){
      FILE *fp=fopen(argv[1],"r");
      if (fp==NULL){
         fp=fopen(argv[1],"w");
         struct Student s;
         int i;
         for(i=0;i<5;i++){
            scanf("%d %s %s %d",&s.id,s.name,s.sex,&s.age);
            fwrite(&s,sizeof(s),1,fp);
         }
         fclose(fp);
      }
      else {
         fseek(fp,0,2);
         int size=ftell(fp);
         int i,n=size/sizeof(struct Student);
         fseek(fp,0,0);
         struct Student *p=(struct Student*)malloc(n*sizeof(struct Student));
         fread(p,n*sizeof(struct Student),1,fp);
         fclose(fp);
   
         for(i=0;i<n;i++){
            printf("%d %s %s %d\n",p[i].id,p[i].name,p[i].sex,p[i].age);
         }
         free(p);
      }
   }
    
    
 4)结构体变量之间的赋值
   int main(){
     struct Student *p,a,b={1,"ss","dd",12};
     a=b; //结构体变量名，不是地址 赋值是所有成员的拷贝  
     p=&a; 
     printf("%d %s %s %d\n",a.id,a.name,a.sex,a.age);
   }
   
   *p->age //错 p->age先结合, 再和*结合 age不是地址
   (*p)->name //错 *p结合,代表结构体变量名 后面只能用. 
   *p->name   //对 p->name先结合,再和*结合 name是地址 所以是是第一个字符
   p->name++  //错 p->name先结合 ++代表name的第1个元素地址 但 name是常量
   ++p->name  //错 p->name先结合 代表name的++ 但name是常量
   
   
   struct Student{
       int id;
       char *name;
       char *sex;
       int age;
   };   
   int main(){
     struct Student *p,a,b={1,"ss","nv",12};
     a=b; //结构体变量名，不是地址 赋值是所有成员的拷贝  
     p=&a; 
     printf("%d %s %s %d\n",a.id,a.name,a.sex,a.age);
   }
   p->sex++;  是v的地址
   *p->sex++; 是n字符  是sex先使用后自加
   *++p->sex; 是v字符
   (++p)->sex;第(从0开始)1个结合的中sex数组名 但越界
   *(++p)->sex; 第1个结构体sex数组中第0个元素值 但越界
    

 5)结构体用途
   (1)文件头或网络传输的数据头（协议）
   (2)用来管理变量，将变量分组进行处理
   (3)实现不确定个数的数据存储,将结构体的地址保存前一个结构体内
   (4)实现接口，将结构体变量扩展声明，结构体的成员是函数指针
   
 实现接口
    //mplay.h
    #ifndef MPLAY_H
    #deinfe MPLAY_H
    
    struct MPlay{
       int (*play)(char *file,int (*handler)(int,int));
       int (*pause)();
       int (*stop)();
    };
    extern struct MPlay m;
    extern struct MPlay n;
    
    #endif
    
    //mplay.c
    #include <stdio.h>
    #include <stdlib.h>
    #include <string.h>
    #include "mplay.h"
    static int (*sendstate)(int,int);
    static int state;  //0 停止  1播放  2暂停
    static void* run(void* arg){           
    }    
    static int play(char *file,int (*handler)(int,int)){     
    }    
    static int pause(){
    }    
    static int stop(){
    }
    
    struct MPlay m={ //*** 在高级编程中常用
        play,
        pause,
        stop
    };


    //mplay_oss.c
    #include <stdio.h>
    #include <stdlib.h>
    #include <string.h>
    #include "mplay.h"
    static int (*sendstate)(int,int);
    static int state;  //0 停止  1播放  2暂停
    static void* oss_run(void* arg){
    }    
    static int oss_play(char *file,int (*handler)(int,int)){
    }    
    static int oss_pause(){
    }    
    static int oss_stop(){
    }
    
    struct MPlay n={ //*** 在高级编程中常用
        oss_play,
        oss_pause,
        oss_stop
    };
    
    //test.c
    #include <stdio.h>
    #include "mplay.h"
    int curstate;
    int getstate(int state,int val){
        curstate=state;
        printf("---- state =%d,val=%d\n",state,val);    
    }
    
    int main(int argc,char **argv){
        char cmd[256];
        struct MPlay* p=&m;
        if (strcmp(argv[1],"m")==0) p=&m;
        else if (strcmp(argv[1],"n")==0) p=&n;
        
        while(1){
           scanf("%s",cmd);
           if (strcmp(cmd,"q")==0) break;
           else if (strcmp(cmd,"p")==0){
                if (curstate==2)
                   p->play(NULL,NULL);
                else {
                   printf("请输入文件名:\n");
                   scanf("%s",cmd);
                   p->play(cmd,getstate); //播放
                }
           }
           else if (strcmp(cmd,"s")==0)
                p->stop();
           else if (strcmp(cmd,"z")==0)
                p->pause();
        }  
   }
     
   
   结构体的两种操作方法
     
     struct A{
     	int x;
     	double y;
     };
     
     int main(){
        struct A a;
        a.x=12;
        a.y=34.2;
        
        int *p=(int*)&a;
        *p=12; //就是 a.x
        
        double *p1=(double *)((int*)&a+1);
        *p1=4.5; //就是 a.y
    }
     
     
     
       
////////////////////////////////////////////////////////////////////////////////////////

数据结构  2
   数据结构：是指数据在内存中的存储方式
   顺序存储、链式存储
   
   顺序存储：即数组  缺点，必须要先知道个数，中途个数不能改，查找时地址偏移，速度快
   链式存储：即一个结构的地址，存在前一个结构内。缺点 不能用地址偏移,速度慢。没有最大个数限制
   
   可实现链式存储有两种类型：结构体、类

   链表类型：单向链表、双向链表、环状链表、队列、栈、树(二叉树)、网
   
1. 单向链表: 即在前面的结构体中记录后面结构体的地址
   	   头插、尾插、中间插入、释放 
   
   练习：用链式存储方式，实现5个学生信息的读取
   
      struct Student{
         int id;
         char name[10];
         char sex[4];
         int age;
         struct Student *next;	
      };
      
      
      
      int main(){	
      	  struct Student *p1,*head=NULL;
      	  int i=0;
      	  while(i++ <5){
      	     struct Student *p=(struct Student *)malloc(sizeof(struct Student));
      	     scanf("%d %s %s %d",&p->id,p->name,p->sex,&p->age);
      	     p->next=NULL;
      	        	     
      	     if (head==NULL) head=p;
      	     else p1->next=p;
      	     p1=p; 
      	  } 	
      }
         
         
         用函数实现链表
      struct Student *tail=NULL,*head=NULL;
      struct Student *creat_stu(){
            static int id;
            struct Student *p=(struct Student *)malloc(sizeof(struct Student));
            scanf("%s",p->name);
            if (strcmp(p->name,"q")==0){
               free(p);
               return NULL;
            }
            p->id=id++;
            p->next=NULL;
            scanf("%s %d",p->sex,&p->age);
            return p;
      }
      
      
      //尾插
      void add_stu(struct Student *p){
         if (head==NULL) head=p; //如果head为NULL 代表现在一个都没有 p即是头又是尾
         else tail->next=p;      //把p存到了原先的尾
         tail=p;
      }
      //头插
      void head_stu(struct Student *p){
         if (head==NULL) tail=p;  //如果head为NULL 代表现在一个都没有 p即是头又是尾
         else p->next=head; //把头存在新的p内
         head=p;
      }
      //有序的中间插入
      void insert_stu(struct Student *p){
        if (head==NULL || p->id <head->id) //如果head为NULL或 id小于头中的值，则按头插处理
           head_stu(p);
        else if (p->id >tail->id) //如果id 大于尾中的值，则按尾插处理
           add_stu(p);
        else {
           struct Student *pre=head; //前一个
           struct Student *cur=head->next; //当前
           while(cur!=NULL){
               if (p->id <cur->id){  //和当前的比，如果小于当前，则插入
                   p->next=cur;   //前一个的内部存新的结构地址
                   pre->next=p;   //当前的地址存入到新的结构内
                   break;
               }
               //------------为下次循环做准备
               pre=cur;
               cur=cur->next;
           }
        }
      }
      
      
      
      void print_stu(){
         struct Student *p=head; //p为当前要操作的结构指针
         printf(" id    name    sex age\n");
         while(p!=NULL){
            printf("%4d %10s %4s %3d\n",p->id,p->name,p->sex,p->age);
            p=p->next;  
         }
      }
      
      void free_stu(){
         struct Student *p=head; //p为当前要操作的结构指针
         while(p!=NULL){
            head=p->next; //将当前要操作的内存中的next变量值保存到head
            free(p); //释放当前结构
            p=head;  
         }
      }
      
      int main(){
        char cmd;
        while(1){
           scanf("%c",&cmd); //输入指令
           if (cmd=='a'){
               while(1){ //循环输入学生信息
                  struct Student *p=creat_stu(); //申请内存并填写数据
                  if (p==NULL) break;
                  add_stu(p); //连接到链表内
               }
           }
           else if (cmd=='p')
             print_stu(); //打印链表
           else if (cmd=='s'){
             free_stu();  //释放链表
             break;
           }
         }
      }
    



笨法
      struct Student *head;
      void add_stu(struct Student *p){//尾插，在没有保存尾地址时的写法
         if (head==NULL) head=p; //如果head为NULL 代表现在一个都没有 p即是头又是尾
         else { //查找尾，最后找到的cur就是尾
            struct Student *cur=head;
            while(cur->next!=NULL) cur=cur->next;
            cur->next=p; 	//将新的结构体地址存入尾内
         }
      }





2. 双向链表: 在一个结构体中，同时保存前面和后面结构体的地址
3. 环状链表：在最后一个结构体中，保存第一个结构体的地址
  
   有n个人，站成一圈，每个人都有编号，开始报数，3倍数的人离开这个圈，问最后剩下的一个人是几号
  
    int main(int argc,char **argv){
        int i,n=atoi(argv[1]);
        struct Num *tail,* head=NULL;
        //环状链表
        struct Num *p,*p1;
        for(i=0;i<n;i++){
           p=(struct Num*)malloc(sizeof(struct Num));
           p->id=i+1;
           p->next=NULL;
           //尾插
           if (head==NULL) head=p;
           else tail->next=p;
           tail=p;
        }
        tail->next=head;
        //报数
        i=1;
        p=head;
        while(p->next!=p){
           if (i%3==0){
              p1->next=p->next;
              free(p);
              p=p1->next; //新的p
              
           }
           else{
              p1=p;
              p=p->next;
           }
           i++;
        }
        printf("---- %d\n",p->id);
    }
   
  

4.  队列：	一个数据保存在结构体中，这个结构体被加入到链表，在使用时，先加入的先使用，使用后，该结构体内存被释放。
          入队  加入   put 
          出队  读取数据并释放 get

    
          头插尾读 或 尾插头读都可以形成队列
    
    struct Num{
       int id; //编号
       struct Num *next;
    };
    
    struct Num *tail,* head=NULL;
    void put(int n){ //入队
         struct Num *p=(struct Num*)malloc(sizeof(struct Num));
         p->id=n;
         p->next=NULL;
         if (head==NULL) head=p;
         else tail->next=p;
         tail=p;
    }
        
    int get(){ //出队
         if (head==NULL) return -1;
         int a=head->id;
         struct Num *p=head;
         head=head->next;
         free(p);
         return a;
    }
        
    int main(int argc,char **argv){
        char cmd;
        while(1){
            scanf("%c",&cmd);
            if (cmd=='q') break;
            else if (cmd=='a'){
               int i;
               scanf("%d",&i);
               put(i);
            }
            else if (cmd=='p')
               printf("-- %d\n",get());
        }
    }
    

   栈：   一个数据保存在结构体中，这个结构体被加入到链表，在使用时，先加入的后使用, 使用后，该结构体内存被释放。
          入栈  加入   put 
          出栈  读取数据并释放 get 
   
      头插头取  或尾插尾取 都是栈
    
    struct Num{
       int id; //编号
       struct Num *next;
    };
    
    struct Num *tail,* head=NULL;
    void put(int n){ //入栈
         struct Num *p=(struct Num*)malloc(sizeof(struct Num));
         p->id=n;
         p->next=NULL;
         if (head==NULL) head=p;
         else tail->next=p;
         tail=p;
    }
        
    int get(){ //出栈
         if (head==NULL) return -1;
         int a=head->id;
         struct Num *p=head;
         head=head->next;
         free(p);
         return a;
    }
        
    int main(int argc,char **argv){
        char cmd;
        while(1){
            scanf("%c",&cmd);
            if (cmd=='q') break;
            else if (cmd=='a'){
               int i;
               scanf("%d",&i);
               put(i);
            }
            else if (cmd=='p')
               printf("-- %d\n",get());
        }
    }      

  
   
    输入一个整数，问该数的8进制数是多少 (不允许用递归和循环)

    struct Num{
       int id; //编号
       struct Num *next;
    };
    
    struct Num *tail,* head=NULL;
    void put(int n){ //入栈
         struct Num *p=(struct Num*)malloc(sizeof(struct Num));
         p->id=n;
         p->next=NULL;
         if (head==NULL) head=p;
         else tail->next=p;
         tail=p;
    }
        
    int get(){ //出栈
         if (head==NULL) return -1;
         int a=head->id;
         struct Num *p=head;
         head=head->next;
         free(p);
         return a;
    }     
      
    int main(int argc,char **argv){
        int a=atoi(argv[1]);
        int j=atoi(argv[2]);
        //计算j进制
        while(a!=0){
           put(a%j);  
           a/=j;
        } 
        //打印
        int o;
        while ((o=get())>=0) printf("%c",o>=10?'A'+o-10:'0'+o);
    }
       
       
   树
     二叉树: 一个结构体中保存两个结构体的地址
     堆：是一种特殊树	
 
     struct Num{
        int id; //编号
        int n;  //级数
        struct Num *left;
        struct Num *right;
     };
     struct Num* creat(int n){
          int num;
          scanf("%d",&num);
          if (num<0) return NULL;
          struct Num* p=(struct Num*)malloc(sizeof(struct Num));
          p->id=num;
          p->n=n;
          p->left= creat(n+1);
          p->right=creat(n+1);
          return p;
     }
     void printtree(struct Num *p){
          if (p==NULL) return;
          int i;
          for(i=0;i<p->n -1;i++) printf("    ");
          if (p->id!=0) printf("|---");
          printf("%d \n",p->id);
          printtree(p->left);
          printtree(p->right);
          free(p);
     }
     int main(int argc,char **argv){
         //创建树
         struct Num *tree=creat(1);
         printf("**************************\n");
         //打印
         printtree(tree);
     
     }
   
   
     1)先序
       先根->左->右
     void printtree(struct Num *p){
          if (p==NULL) return;
          printf("%d \n",p->id);
          printtree(p->left);
          printtree(p->right);
          free(p);
     }       
       
     2)中序
       左->根->右
      void printtree(struct Num *p){
           if (p==NULL) return;
           printtree(p->left);
           printf("%d \n",p->id);
           printtree(p->right);
           free(p);
      }       

     3)后序
       左->右->根    
      void printtree(struct Num *p){
           if (p==NULL) return;
           printtree(p->left);
           printtree(p->right);
           printf("%d \n",p->id);
           free(p);
      }    
   
   
////////////////////////////////////////////////////////////   
常见算法  
一、数组排序
       选择排序、插入排序、交换排序
   
   
1.直接插入排序
     将待排序的数按大小，插到前面排好数据的适当位置。
     
     11，8，1，10，7，4，12,2，3，6，5，9
 
 实现方法：在已排数据中，只要比待排大，则向后移动一格，在这个大数据倒出一个空格，直到比这个待排的小为止，最后将待排的插入到空格处.
     
     int main(int argc,char **argv){
         int a[]={1,12,11,8,10,7,4,2,3,6,5,9};
         int i,j,n=12;
         for(i=1;i<n;i++){//要排数的下标
            int tmp=a[i]; //将待排的元素保存到临时变量中
            j=i-1;
            while(j>=0 && a[j]>tmp){ //j代表已排的下标
                a[j+1]=a[j]; //元素向后移动
                j--;   //下标递减
            }
            a[j+1]=tmp;//赋给空出位置的元素
         }
         for(i=0;i<n;i++) printf("%d ",a[i]);
     }
     
2.直接选择排序法
    是从待排序的数据中选出最小的值，顺序存放在已排序的数据后面
    
    int main(int argc,char **argv){
        int a[]={11,8,1,10,7,4,12,2,3,6,5,9};
        int i,j,n=12;
        for(i=0;i<n;i++){ //i代表已排序后面的数的下标
           int min=i;
           for(j=i;j<n;j++){//在待排序数中找到最小的下标
              if (a[min] > a[j]) min=j;
           }
           //如果找到的最小的和已排序后面数的值不同，则换
           if (a[i]>a[min]){
           	  int tmp=a[i];
              a[i]=a[min];
              a[min]=tmp;
           }
        }
        for(i=0;i<n;i++) printf("%d ",a[i]);
    ｝
   
  

3.冒泡排序（交换排序）
   
  两两比较待排序数，交换不满足顺序的两个数
  
    int main(int argc,char **argv){
        int a[]={11,8,1,10,7,4,12,2,3,6,5,9};
        int i,j,n=12;
    
        for(i=1;i<n;i++){ //i代表第i轮 共n-1轮
            for(j=0;j<n-i;j++){ //j代表下标 共比较n-i次
               if (a[j] >a[j+1]){
                  int tmp=a[j];
                  a[j]=a[j+1];
                  a[j+1]=tmp;
               }
            } 
        } 
        for(i=0;i<n;i++) printf("%d ",a[i]);
    }    
 
   
二、链表排序
1.改内容
    不可取
    
2.改变链表的链接 (了解)
    struct Num{
       int n;
       struct Num *next;
    } *head,*tail;
    
    struct Num* creat(int n){
       struct Num *p=(struct Num*)malloc(sizeof(struct Num));
       p->n=n;
       p->next=NULL;
       return p;
    }
    
    void add(struct Num *p){
       if (head==NULL) head=p;
       else tail->next=p;
       tail=p;
    }
    
    void print(){
       struct Num *p=head;
       while(p!=NULL){
          printf("%d ",p->n);
          p=p->next;
       }
       printf("\n");
    }
    
    void sort(){
       struct Num *nhead=NULL,*ntail;
       while(head!=NULL){
           //找最小的地址
           struct Num *min=head,*premin=NULL,*p=head,*p1=NULL;
           while(p!=NULL){
              if (min->n >p->n) {
                  premin=p1; //最小值的前一个地址
                  min=p;     //最小值的地址
              }
              p1=p;
              p=p->next;
           }
          //将结构体从原链中摘除
           if (premin==NULL) head=min->next;//如果要摘的是头,则确定新头
           else premin->next=min->next;
           //新链尾插
           if (nhead==NULL) nhead=min;
           else ntail->next=min;
           ntail=min;
       }
       //将新的头和尾，重新保存到原的头和尾变量内
       head=nhead;
       tail=ntail;
    }
      
    int main(int argc,char **argv){
        int a;
        while(1){
           scanf("%d",&a);
           if (a==-1) break;
           struct Num* p=creat(a);
           add(p);
        }
        //------------------
        print();
        sort();
        print();
    }



2.建立索引表  ****

   struct Num** sort(int *gs){
      //将结构体的地址保存到数组中
      struct Num *p=head,**a=(struct Num**)malloc(count * 4);//索引表
      int i=0,j;
      while(p!=NULL) {
          a[i++]=p;
          p=p->next;
      }
      //排序
      for (i=1;i<count;i++){
         for(j=0;j<count-i;j++){
           if (a[j]->n > a[j+1]->n){
              struct Num *tmp=a[j];
              a[j]=a[j+1];
              a[j+1]=tmp;
           }
         }
      }
      *gs=count;
      return a;
   }
   
   int main(int argc,char **argv){
       int a;
       while(1){
          scanf("%d",&a);
          if (a==-1) break;
          struct Num* p=creat(a);
          add(p);
       }
       //------------------
       print();
       int i,n;
       struct Num **b=sort(&n);
       for(i=0;i<n;i++) printf("%d ",b[i]->n);
       free(b);
   }
  
   
三、查找
   
1.无序数组查找
  1,11,8,10,7,4,12,2,3,6,5,9
  找到 3 并打印
  依次遍历(即从头到尾来比较)
  

2.有序数组查找
  1 2 3 4 5 6 7 8 9 10 11 12
  
   二分法，也称折半法  
   int main(int argc,char **argv){
       int a[]={1,2,3,4,5,6,7,8,9,10,11,12};
       int b=atoi(argv[1]);
       int min=0,max=11,mid;
       int sign=0; //1代表找到 0没找到
       while(min<=max && !sign){
           mid=(min+max)/2;
           if (a[mid]==b) sign=1; //找到了 mid就是要找的值的下标
           else if (a[mid] > b) max=mid-1;
           else min=mid+1;
       }
       if (sign==1) printf("---- %d\n",a[mid]);
       else printf("没找到\n");
   }


3.链表查找   

  1)无序链表
    遍历
  2)有序链表 
    遍历
  3)索引表(哈希)
    同数组二分法    


4.将链表保存到文件
     struct Num{
        int n;
        struct Num *next;
     } *head,*tail;
     
     int count;
     struct Num* creat(int n){
        count++;
        struct Num *p=(struct Num*)malloc(sizeof(struct Num));
        p->n=n;
        p->next=NULL;
        return p;
     }
     void add(struct Num *p){
        if (head==NULL) head=p;
        else tail->next=p;
        tail=p;
     }
     
     void print(){
        struct Num *p=head;
        while(p!=NULL){
           printf("%d ",p->n);
           p=p->next;
        }
        printf("\n");
     }
     int msave(char *file){
        FILE *fp=fopen(file,"w");
        if (fp==NULL) return -1;
        struct Num *p=head;
        while(p!=NULL){
           fwrite(p,sizeof(struct Num),1,fp);
           p=p->next;
        }
        fclose(fp);
        return 0;
     }
     int mopen(char *file){
        FILE *fp=fopen(file,"r");
        if (fp==NULL){
            printf("---- open err=%s\n",strerror(errno));
            return -1;
        }
        fseek(fp,0,2);
        int i=0,n=ftell(fp)/sizeof(struct Num);
        fseek(fp,0,0);
        while(i<n){
           struct Num *p=(struct Num*)malloc(sizeof(struct Num));
           fread(p,sizeof(struct Num),1,fp);
           p->next=NULL;
           add(p);
           i++;
        }
        fclose(fp);
        return 0;
     }
     int main(int argc,char **argv){
        int err= mopen(argv[1]);
        if (err==0){
            print();
        }
        else {//失败
             int a;
             while(1){
                scanf("%d",&a);
                if (a==-1) break;
                struct Num* p=creat(a);
                add(p);
             }
             msave(argv[1]);
        }
     }



////////////////////////////////////////////////////////////

实现功能:增删改查输出
需求分析: 给用户、老板、项目经理或系统架构师看 
    要做什么，做成什么样子？
    科室
    职位
    职工信息表
    考勤
    人事离职、入职
    办公
    .....
    
概要设计: 给老板、项目经理、资深工程师看
    如何做？
    模块：按部门来划分模块、按功能划分模块
    使用接口实现模块衔接
    
    工作流程
    数据流程
    程序流程
    
    可能的技术难点? 找出解决办法
    解决方案中可能有多种解决方式，选择哪一种方式要确定
    
详细设计: 给项目经理、程序看
    规划各种接口 
    确定接口的函数格式
    每一个模块中，代码的流程
    确定数据表的结构和数据表之间的关系  
    原则：只要数据表中有重复录入的数据，就单独抽离出来形成一个新的表 
         
    达到程度：程序员不需要思考，只需要写代码即可
             
编码

测试    
    
    
    银行信息管理系统
    要求只实现一个数据表记录员工的信息
    
    
    
    
////////////////////////////////////////////////////////////
文件编译  
一、gcc编译指令各项参数
 四个步骤
     预处理  -E   gcc -o test.i -E test.c
     汇编    -S   gcc -o test.s -S test.c
     机器码  -c   gcc -o test.o -c test.c
     链接    依赖的文件 gcc -o test test.o
     -o 生成目标
     -g 调试
     

 1.常用参数
   -L  指定库文件所在的目录
       静态库 .a  链接时被编译到可执行程序中，运行时在可执行文件中找函数
       动态库 .so 链接时只是指定了要调用的库，运行时到/lib 里去找函数库
       
       库文件名 前缀+库名+后缀
                lib       .a  .so
                
                libm.a 是math.h  libm.a是库文件名 m是库名       
       库名     
   -l  指定库名
       
       gcc -o test test.c mplay.c -L/usr/lib -lpthread
       pthread是库名 库文件名在/usr/lib目录中，-L可省略  -l必须存在

       -static 代表强制使用静态
       -shared 动态

   -I  用来指定头文件所在的目录
       gcc -o test -I./lib -include mplay.h test.c ./lib/mplay.c -lpthread

       gcc -o test -I./lib test.c ./lib/mplay.c -lpthread

   -include 用来指定引入头文件
      gcc -o test -include mplay.h test.c mplay.c -lpthread


   -L 和-l是链接时使用
   -I 和-include 机器码时使用
   
 2.其它参数
   -shared 生成共享目标文件。通常用在建立共享库时。
   -static 禁止使用共享连接。
   -w 不生成任何警告信息。
   -Wall 生成所有警告信息。
   -O0 不进行优化处理。
   -O  或 -O1 优化生成代码。
   -O2 进一步优化。
   -O3 比 -O2 更进一步优化，包括 inline 函数。
   -g 生成调试信息。GNU 调试器可利用该信息。
   -ansi 只支持 ANSI 标准的 C 语法。
   -pipe 使用管道
   
   
   
 3.静态库编译
   两个步骤
   1)生成机器码 -c
   2)用ar编译静态库
     gcc -o mplay.o -c mplay.c
     ar -rc libmplay.a mplay.o

     库的使用
     gcc -o test -I./lib test.c -L./lib -lmplay -lpthread 
     
     -lm   指针libm.a 里面是函数的定义
     math.h 是libm.a内函数的扩展声明
     
    
 4.动态库编译
    1)生成机器码 -c
    2)用gcc编译静态库 -shared -fPIC
     gcc -o mplay.o -c mplay.c
     gcc -shared -fPIC -o libmplay.so mplay.o 

    库的使用
    gcc -o test -I./lib -include mplay.h test.c -L./lib -lmplay -lpthread
      
    将libmplay.so拷贝到/lib中然后运行程序

    强制指定使用静态库编译程序     
    gcc -o test -I./lib -include mplay.h test.c -L./lib -lmplay -lpthread -static


 5.c++调用标准c的函数
   //test.cpp
   extern "C"{
   #include "mplay.h"   
   }
 
 
   
二、makefile的编写
   

 1.makefile基本原理
   本质就是一个脚本，这个脚本用make来执行
   文件名makefile或Makefile
   
   原理，是根据目标，执行下面的指令
         目标后面如果还有依赖的目标，则先执行后面目标的指令，再执行前面目标的指令
         
   aaa:
           find ./ -name "*"
   eee:rrr
           ls
   rrr:
           echo "adfadsf"
         
 
      
 2.基本结构 基础
   可执行名:依赖的.o 依赖的库
          链接
     
   依赖的库：依赖的.o
          生成库的指令       
 	 依赖的.o:
 	 	      生成.o的指令
    
   test:test.o libmplay.a
           gcc -o test test.o -L./ -lmplay -lpthread
   libmplay.a:mplay.o
           ar -rc libmplay.a mplay.o
   test.o:
           gcc -o test.o -c test.c
   mplay.o:
           gcc -o mplay.o -c mplay.c
   clean:
           rm -rf *.o libmplay.a test
      
   
   test:test.o libmplay.a
           gcc -o test test.o -L./ -lmplay -lpthread
   libmplay.a:mplay.o
           ar -rc libmplay.a mplay.o
   #将多个.o的目标合并在一起        
   test.o mplay.o:
           gcc -c test.c mplay.c
   clean:
           rm -rf *.o libmplay.a test

           
 2.自动推导 很少用
   
      test:test.o libmplay.a
              gcc -o test test.o -L./ -lmplay -lpthread
      libmplay.a:mplay.o
              ar -rc libmplay.a mplay.o
      test.o mplay.o:  
      #此处的.o文件自动推导生成
      clean:
              rm -rf *.o libmplay.a test
 
 
 3.使用变量
 
 1)局部变量
   SRC=test.c mplay.c
   
   变量的取值
   $(SRC) 就是 test.c mplay.c  
   
   字符串中字符的替换
   SRC=test.c mplay.c
   OBJ=$(SRC:.c=.o)  #将变量src中的字符串的.c换为.o
   
   makefile可写成  方法1
     TAR=test
     SRC=test.c mplay.c
     OBJ=$(SRC:.c=.o)
     LIB=-lpthread
     INC=-I./
     CC=gcc
     
     $(TAR):$(OBJ)
             $(CC) -o $(TAR) $(OBJ) $(LIB)
     $(OBJ):
             $(CC) -c $(INC) $(SRC)
     clean:
             rm -rf $(OBJ) $(TAR)

    变量名起名
      AR       代表的是库编译器 例 AR=ar
      ARFLAGS  代表库编译的参数 例 ARFLAGS=-rc
      AS       代表的是汇编译器 例 AS=as
      ASFLAGS  代表汇编的参数  
      CC       代表的是标准C编译器，如 CC=gcc
      CFLAGS   代表是编译.o文件时标准C参数，如 GFLAGS=-Wall -O2 -g -pipe   
      CXX      代表的是C++编译器 例 g++
      CXXFLAGS 代表c++参数      
      LFLAGS   代表编译可执行文件时参数 ，如 LFLAGS=-Wall -O2 -g -pipe 
      LIBS     代表编译可执行文件时链接库，如 LIBS=-L./ -lm
      SRCS 或 SOURCES    代表源码文件 .c或.cpp ，如 SOURCES=test.c fun.c
      OBJS 或 OBJECTS     代表依赖文件.o  ，如 OBJECTS=test.o fun.o
      EXE  或 TARGET     代表可执行文件  ，如 TARGET=test
      INPATH 或 INCLUDE  代表所需要的头文件位置，如 INCLUDE=-I./ -include "fun.h"

   
  2)内部变量(预定义变量) 
      预定义变量，是脚本中具有特定意义的变量。
    $*     不包含扩展名的目标文件名称，即test fun等 很少使用
*   $+     所有的依赖文件，以空格分开，并以出现的先后为序，可能包含重复的依赖文件。
**  $<     依赖文件的名称，如test.c fun.c等
*   $?     所有的依赖文件，以空格分开，这些依赖文件的修改日期比目标的创建日期晚。
**  $@    目标的完整名称，如test.o fun.o等
*   $^     所有的依赖文件，以空格分开，不包含重复的依赖文件。
*   $%    所有的库文件 .so .a 等
 
  (1)静态模式 %   
     %.o:%.c
        $(CC) -c $< -o $@ $(INC)

         $< 所有的.c
         $@ 所有的.o
    
     makefile可写成  方法2  
        TAR=test
        SRC=test.c mplay.c
        OBJ=$(SRC:.c=.o)
        LIB=-lpthread
        INC=-I./
        CC=gcc
        
        $(TAR):$(OBJ)
                $(CC) -o $(TAR) $(OBJ) $(LIB)
        %.o:%.c
                $(CC) -c $< -o $@ $(INC)
        clean: 
                rm -rf $(OBJ) $(TAR)

  
   (2)后缀规则
      .o.c:
        gcc -c $< 
       
       $< 所有的.c
  
      makefile可写成  方法3  
        TAR=test
        SRC=test.c mplay.c
        OBJ=$(SRC:.c=.o)
        LIB=-lpthread
        INC=-I./
        CC=gcc
        
        $(TAR):$(OBJ)
                $(CC) -o $(TAR) $(OBJ) $(LIB)
        .o.c:
                $(CC) -c $< $(INC)
        clean: 
                rm -rf $(OBJ) $(TAR) 
 
 
 7.makefile之间的调用
   -C DIRECTORY
   
   make -C /home/    //用-C来指定编译哪个目录下的makefile

   
   -f FILE 
 
   make -f Makefile1 //指定用哪个makefile 来编译
   
   makefile可写成  方法4  

      TAR=test
      SRC=test.c
      OBJ=$(SRC:.c=.o)
      LIB=-L./lib -lmplay -lpthread
      INC=-I./lib
      CC=gcc
      
      all:creatlib $(TAR)
      creatlib:
              make -C ./lib
      $(TAR):$(OBJ)
              $(CC) -o $(TAR) $(OBJ) $(LIB)
      %.o:%.c
              $(CC) -c $< $(INC)
              
      clean:cleanlib
              rm -rf $(OBJ) $(TAR)
      cleanlib:
              make -C ./lib clean

 
 8.qmake生成makefile
     qmake是qt的工具 用来生成工程文件和makefile
     
     //生成工程文件
     qmake -project -o test.pro
     
     //生成makefile
     qmake
     
     //编译程序
     make
 
 9.configure生成makefile
    
//////////////////////////////////////////////////////////////
综合试题答案
一、
1-5   D  D  C  B  B
6-10  D  B  D  A  C
11-15 A  A  D  C  A
16-20 D  A  B  B  B

二、
1.  0x0f  00001111
2.  34

三、
1.  错
2.  对
3.  错
4.  错
5.  错
6.  错
7.  对
8.  错
9.  错
10. 错
四、
1. 
   变量定义的本质是申请内存
   变量声明不会产生内存
2.
   占用内存大小相同，都是4字节
   因为保存的都是内存地址，内存地址是无符号长整型
3.
   参数段
   数据段时内存：加载程序时分配内存，关闭程序时释放内存
   堆区内存：用malloc申请，free释放
   栈区内存：在函数内定义变量就是分配内存，作用域结束后自动释放内存
   代码段内存：  加载程序时分配内存，关闭程序时释放内存
4.
   sprintf 按格式生成的字符串保存到指定内存中
   strcpy  是将指定的内存中的字符串拷贝到另一内存中 \0结束
   memcpy  是将指定的内存中的数据拷贝到另一内存中 需要指定长度
   
   strcpy拷贝字符串方便，自动识别字符串是否结束
   
5.
   链表，后一个结构体的地址存在了前一个结构体内部,想找到后一个结构体必须先找到前一个结构体
   数组，顺序存储，每一个结构体之间内存空间连续，通过地址偏移就可以找到后一个结构体
   指针, 是指针变量，用来保存内存地址 
五、
1.
   char *s=str[len]改为  char *s=src+len-1 或 char *s=&src[len]-1;
   d++=s--改为 *d++=*s--;

2.

typedef struct {
   TNode* left;
   TNode* right;
   int value;
} TNode;
改为
typedef struct NODE{
   struct NODE* left;
   struct NODE* right;
   int value;
} TNode;


   增加
   NewNode->left=NULL;
   NewNode->right=NULL;
 
   将所有的temp.改为temp->   

六、
1.

int main(int argc,char **argv){
    FILE *fp=fopen(argv[1],"r");
    if (fp==NULL) return -1;
    char buf[256];
    fseek(fp,0,2);
    int size=ftell(fp);
    fseek(fp,0,0);
    fread(buf,size,1,fp);
    fclose(fp);
    //------------------------
    char *p=buf;
    int n=0;
    while((p=strstr(p,argv[2]))!=NULL){
        n++;
        p=p+strlen(argv[2]);
    }
}
   
   
2.
typedef struct {
   int n;
   char name[20];
   double jb;
   double zw;
} Worker;

int main(){
    Worker w[10];
    int i=0,min=0;
    for(i=0;i<10;i++){ 
       scanf("%d %s %lf %lf",&w[i].n,w[i].name,&w[i].jb,&w[i].zw);
    }
    for(i=0;i<10;i++){
       if (w[i].jb+w[i].zw < w[min].jb+w[min].zw) min=i;
    }
    printf("%d %s %lf %lf\n",w[min].n,w[min].name,w[min].jb,w[min].zw);
}


~    
3.
struct Num{
   int n;
   struct Num* next;
} *head,*tail;

void put(int n){
   struct Num *p=(struct Num*)malloc(sizeof(struct Num));
   p->next=NULL;
   p->n=n;
   if (head==NULL) head=p;
   else tail->next=p;
   tail=p;
}

void print(){
   struct Num* p=head;
   while(p!=NULL){
      printf("%d\n",p->n);
      p=p->next;
   }
}

方法一
struct Num* dao1(struct Num * p){
   if (p->next==NULL) return p;
   struct Num* p1=p->next;
   struct Num* h=dao1(p->next);
   p1->next=p;
   if (p==head) head->next=NULL;
   return h;
}
方法二
struct Num* dao2(struct Num *p){
   struct Num *h=NULL,*t=NULL;
   while(p!=NULL){
      head=p->next;
      if (h==NULL) {
          t=p;
          t->next=NULL;
      }
      else p->next=h;
      h=p;
      
      p=head;
   }
   return h;
}
int main(){
    int i=0;
    for(i=0;i<10;i++) put(rand()%100);
    print();
    head=dao2(head);
    print();
} 


sprintf不仅仅支持数字
   char buf[256];
   char *str="asdf",*str2="bbb";
   sprintf(buf,"%s%s",str,str2);
   sprintf(buf,"%s%d",str,45);
   

